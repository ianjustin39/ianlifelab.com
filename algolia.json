[{"authors":null,"categories":null,"date":1651449600,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1651449600,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/blog/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/blog/","section":"blog","summary":"","tags":null,"title":"Blog","type":"blog","url":"/ianlife/blog/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1651449600,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomyTerm","lang":"zh","lastmod":1651449600,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/categories/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/categories/","section":"categories","summary":"","tags":null,"title":"Categories","type":"categories","url":"/ianlife/categories/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1651449600,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"home","lang":"zh","lastmod":1651449600,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/","section":"","summary":"","tags":null,"title":"Life Story","type":"page","url":"/ianlife/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1651449600,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1651449600,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/series/pm-101/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/series/pm-101/","section":"series","summary":"","tags":null,"title":"PM 101","type":"series","url":"/ianlife/series/pm-101/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1651449600,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1651449600,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/categories/product/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/categories/product/","section":"categories","summary":"","tags":null,"title":"PRODUCT","type":"categories","url":"/ianlife/categories/product/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1651449600,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomyTerm","lang":"zh","lastmod":1651449600,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/series/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/series/","section":"series","summary":"","tags":null,"title":"Series","type":"series","url":"/ianlife/series/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1651449600,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomyTerm","lang":"zh","lastmod":1651449600,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/","section":"tags","summary":"","tags":null,"title":"Tags","type":"tags","url":"/ianlife/tags/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1651449600,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1651449600,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/wireframe/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/wireframe/","section":"tags","summary":"","tags":null,"title":"wireframe","type":"tags","url":"/ianlife/tags/wireframe/","weight":0,"wordcount":0},{"authors":null,"categories":["PRODUCT"],"date":1651449600,"description":"wireframe 是產品開發現場的建築藍圖，不是草稿","dir":"blog/product/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":["wireframe"],"kind":"page","lang":"zh","lastmod":1651449600,"objectID":"bda465589688f34fe88b6024df244edf","permalink":"https://ianjustin39.github.io/ianlife/blog/product/product/pm101-wireframe/","publishdate":"2022-05-02T00:00:00Z","readingtime":1,"relpermalink":"/ianlife/blog/product/product/pm101-wireframe/","section":"blog","summary":"最近畫 Wireframe 的頻率有點高，也畫出了一些心得，中間也有遇到一些問題，剛好分享紀錄一下。\n什麼是 Wireframe  基本的 Wireframe 是一種低保真的設計原型，頁面上面沒有華麗的設計元素，只有匡線、文字資訊、架構排版等。 在一個新的需求出現時，會有非常多的不確定性，需要先確定產品要呈現什麼資訊給用戶、使用旅程是什麼、可能遇到什麼問題、我們想解決什麼問題等， 都需要考慮進去，所以若是太快進入 UI 設計，如果架構或是流程等部分需要做更改，可能會造成過多的資源消耗。\n畫 Wireframe 目的是什麼？  我認為 Wireframe 階段主要考慮以下兩個部分：\n 傳遞資訊 使用者流程  以下會拿會員系統內新增訂單功能來做範例：\n傳遞資訊 畫面上要呈現什麼類型的資訊給用戶，必須在 Wireframe 階段就決定， 使用適當的文字幫助用戶理解情境，讓用戶可以很簡單的知道新功能的價值是什麼。\n比方說，電商會員系統中新增了查詢訂單的功能，用戶在登入會員後會希望去看自己的訂單狀況， 或許在會員頁面上用一段文字提醒目前訂單狀況，讓用戶知道自己的訂單現在的狀況。\n使用者流程 接續上述訂單狀況，當用戶看到自己訂單狀況時，要怎麼樣引導他去看到自己的訂單。 可以在文字附上超連結導去訂單頁面，也可以在畫面上新增『我的訂單』的分頁，讓用戶可以用最短時間內找到自己的訂單， 又或是當用戶遇到錯誤時，是不是有明確的提示可以讓他解決當下的問題。\n所以 Wireframe 除了傳達資訊以外，使用者流程也是很重要的一環，用戶看到關鍵訊息後，可以很簡單的使用新功能。\nWireframe 常見的錯誤  第一次畫 Wireframe 的人很有可能落入『濫用視覺元素』這個錯誤，畫著畫著就會開始想頁面的顏色要怎樣呈現比較好按鈕形狀長怎樣， 要放什麼 icon 在畫面上，在顯示圖片的地方要放哪張圖等。 但這些東西並不是在 Wireframe 階段該專注的事情，上面有提到 Wireframe 專注於傳遞資訊，包含資訊架構、功能、流程等等， 而不是設計，所以用最簡單基本的方式呈現，剩下精緻的設計就讓設計師煩惱吧。\n以下幾個是我從零開始畫 Wireframe 時會注意的幾點：\n 只用灰白色，專注於架構的呈現 單一字體，專注於傳達資訊 只用 3, 4 種字級 不用照片或插圖，用方框框代替 不用強烈風格的 icon 或裝飾圖  但有些產品已經很成熟，在 Wireframe 階段會拿既有的畫面去改，這時要注意的點便是每個畫面或是元件所使用的場景是什麼。 以電商來說，買家的訂單元件以及賣家的訂單元件可能就長得不一樣，這時如果混用的話，由於已經算是高保真的設計， 這時一同討論的工程師或是設計師可能會因為精緻的畫面，而跳過『討論資訊架構』的階段，開始思考畫面的問題。 所以當使用既有的畫面去做 Wireframe 時要注意使用的元件要正確，不能混用，導致誤會。","tags":["wireframe"],"title":"畫 Wireframe 目的是什麼？","type":"PM 101","url":"/ianlife/blog/product/product/pm101-wireframe/","weight":0,"wordcount":83},{"authors":null,"categories":null,"date":1650931200,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1650931200,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/categories/learning/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/categories/learning/","section":"categories","summary":"","tags":null,"title":"Learning","type":"categories","url":"/ianlife/categories/learning/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1650931200,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1650931200,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/%E5%A5%BD%E6%9B%B8%E6%8E%A8%E8%96%A6/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/%E5%A5%BD%E6%9B%B8%E6%8E%A8%E8%96%A6/","section":"tags","summary":"","tags":null,"title":"好書推薦","type":"tags","url":"/ianlife/tags/%E5%A5%BD%E6%9B%B8%E6%8E%A8%E8%96%A6/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1650931200,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1650931200,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/series/%E5%BE%9E%E7%8F%BE%E5%9C%A8%E9%96%8B%E5%A7%8B%E8%AA%8D%E7%9C%9F%E8%AE%80%E6%9B%B8/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/series/%E5%BE%9E%E7%8F%BE%E5%9C%A8%E9%96%8B%E5%A7%8B%E8%AA%8D%E7%9C%9F%E8%AE%80%E6%9B%B8/","section":"series","summary":"","tags":null,"title":"從現在開始認真讀書","type":"series","url":"/ianlife/series/%E5%BE%9E%E7%8F%BE%E5%9C%A8%E9%96%8B%E5%A7%8B%E8%AA%8D%E7%9C%9F%E8%AE%80%E6%9B%B8/","weight":0,"wordcount":0},{"authors":null,"categories":["Learning"],"date":1650931200,"description":"給予、索取、互利是三種人際的互動模式，在生活、職場上，每個人都可能扮演不同的角色，與不同對象互動時會採取不同的互動模式。比方說，在求職談薪水時會展寫出索取者的姿態，但在指導新人的時候又會變成給予者的模式。","dir":"blog/learning/reading/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":["讀書心得","給予","give and take"],"kind":"page","lang":"zh","lastmod":1650931200,"objectID":"da734e4898e7a46c07b4e4d4d2f24208","permalink":"https://ianjustin39.github.io/ianlife/read/give-and-take/","publishdate":"2022-04-26T00:00:00Z","readingtime":1,"relpermalink":"/ianlife/read/give-and-take/","section":"blog","summary":"1. 誰在金字塔的頂端？  給予、索取、互利是三種人際的互動模式，在生活、職場上，每個人都可能扮演不同的角色，與不同對象互動時會採取不同的互動模式。 比方說，在求職談薪水時會展寫出索取者的姿態，但在指導新人的時候又會變成給予者的模式。\n那以職場來講，誰在金字塔的底部，而又是誰在頂層呢？你可能會猜在金字塔底部的應該是給予者，因為給予者喜歡給予，但也是因為這一點，在給予的過程中給予者可能會犧牲自己的權益。\n加州有份調查報告是有關於工程師在工作上的生產力以及效率，統計發現表現最差的工程師確實是給予比索取多的人，這些人為了幫助別人付出更多心力，但也無法好好的完成工作。 那頂層是索取者還是互利者呢？在同一份調查結果顯示，生產力最高的一樣式給予者，工作成果評分最高的工程師一直樂於貢獻。 當然這種現象不只出現在工程師，同樣也有一份調查是針對業務員，結果就如同工程師的統計一樣，不管是表現最差還是最好的，都是給予者。\n那為何在金字塔的頂端以及底部都是給予者呢？\n2. 影響力真空，頂與底的給予者  大家普遍會認為，過多的給予只會造成自己的困擾，但是其實許多成功者本質上也喜歡給予，頂端與底部的給予者本質上的差異又是什麼呢？ 底層的給予者屬於『無私奉獻型』給予者，他們重視他人的利益，但卻過度忽視自己的利益，把時間和精力花在奉獻上，而不顧自己的需求。 頂端的給予者屬於『利人利己型』給予者，他們關注於他人利益的同時，也重視著自己的利益。 可能多數人會認為『利己』以及『利人』在光譜的兩邊，而這是否也更像互利者？\n書中提到的電訪員的故事，該部門的電訪員需要打給畢業校友募款，其中給予型的電訪員業績普通，甚至稱不上好，但索取型的電訪員業績則是給予型的好幾倍。 索取型的電訪員在這個部門的薪水是最高的，這也是他的動力之一，也是他們的『獎勵』。但給予型電訪員想要的獎勵卻不是錢，他更在意自己可以有什麼貢獻。 電訪員所募來的資金大多數會作為大學生的獎學金，這筆獎學金可以幫助到不少的學生完成學業。當給予型電訪員知道這個原因後，只花了一週業績就追上了索取型電訪員。\n給予者『利己』的目標較於互利者以及索取者不太一樣，他們更在意自己做的事是否可以幫助到他人。 當自己所做的事可以對他人產生價值時，給予者的成就往往會高出另外兩者許多，如果沒有，就會在底層打滾，這種現在稱作『影響力真空』。\n3. 如何找到人才  世界上一些有名的網球選手，第一個網球教練並不是超強的教練，但這些教練大多都很會帶小朋友，他們提供了孩子動力，讓他們對網球產生興趣，願意花時間去練習。\n給予者擔任領導及教導的角色時，能力並不是他們考量的第一要點，他們認為每個人都有『潛力』。 這些選手的教練，會特別關照他們，並不是因為他們天賦異稟，而是因為他們有過於常人的決心、肯努力。 心理學家把這種特質稱作韌性 (grit)：對長程目標有熱情及毅力。\n但這並不代表天賦不重要，只是當有一群能力都過門檻的人，韌性就會成為指標，能預測這些人發揮潛力的程度，這也是為什麼對於給予者來說，栽培有韌性的人 CP 值最高的原因。\n在職場上同理，給予型的主管會提攜後輩，他認為人人都是『潛力股』，並且他也不會畏懼能力出眾的下屬，因為給予者的目標並不是個人的成就，而是大家的成就。 但索取者就不一樣了，索取者會預設立場，懷疑別人立意不良，若遇到有潛力的人會視為威脅，不願支持與栽培，較少扮演扶植者。 而互利者是只要發現有潛力，就會給予支持，但這相對也是缺點，因為互利者通常都看到指標才會行動，不願意冒險，這也讓他們有可能錯失有潛力的人才。\n4. 給予的力量，團隊分享  給予的力量到底有多大？\n試想自己在職場上，提出了一個創新的方案，主管在跟老闆提案時說『這是我花一個月想出來的方案』以及『這是 XXX 提出，並經由團隊共同討論得出的方案』 哪個更願意讓人繼續追隨。\n一個團隊的成功，團隊裡的給予者，並不會去搶功勞，因為他希望整個團隊都一起成功。 而索取者則會認為，功勞都是自己的，別人只是幫他抬轎而已，他不願意分享成果。 雖然『搶功勞』對於索取者來說並不影響他的成就，但『分享成果』這件事卻會促使給予者的成功。 因為這對於給予者來說，分享的當下可能會損失一些收入或名氣，但把時間拉長，相較於索取者，大家更願意主動推薦給予者，跟他一起合作， 而互利者也只會想要獎勵給予者，懲罰索取者。\n5. 給予者如何避免成為別人的『墊腳石』  給予者在某種程度上還是會成為索取者的『墊腳石』，索取者可能會假扮成給予者，讓給予者認為好像遇到志同道合的人，但其實只是想要利用給予者而已。 大家可能會認為『這個人感覺還不錯』他就是給予者；『這個人相處起來不舒服』他一定是索取者。 一開始認識朋友，當他對你冷淡，會以為對方不在乎我們，因為我們對他沒有利益，所以他是索取者。 但在生活上也可能遇到『討人喜歡的給予者』，所以『討人喜歡』與否，只是一個印象，並不能代表索取者或給予者。\n如何分辨真假給予者？『真程度篩選』是給予者分辯索取者及互利者的一個方法，給予者相較於其他兩類人更有辦法分辨出誰是索取者及互利者。 因為給予者比較會注意他人的行爲舉止，也比較能了解別人的思緒和感覺，因此更能察覺出一些線索。 第二點就是，他們很容易信任別人，可能有時會被索取者背刺，但也可能因為自己的付出獲得超值的回報。 時間一長，給予者對於每個人之間的差異就會更敏感，便不會落入『討喜』或『不討喜』的選擇題內。\n給予者在可以分辨真假給予者後，便會依照對方的類型改變自己的互動方式，書中稱此行為叫做『寬容版的以牙還牙』。 賽局理論中的以牙還牙的策略，是典型的互利做法。也就是一開始先配合對方的做法，當對方開始競爭後，才開始改採競爭做法，但缺點則是對於偶發事件不夠寬容。 而寬容版的以牙還牙則是開始一樣採配合做法，當對方開始競爭後，才開始改採競爭做法，但也不是每次都與其競爭，2/3 採競爭做法，其餘則是選擇寬恕配合。 這對於給予者來說是一個彈性，遇到索取者時給予者有辦法與他來回互動，不在是單方面給予。\n讀後心得  在社會上打滾幾年後來看『給予』這本書特別有感觸，社會上形形色色的人都有，如何找到正確的人，與不同類型的人合作，一直都是重要的課題。 職涯一路走來也受到不少人的幫助，自己也會想究竟為何有人就是未將手伸出來幫助別人，救自己都來不及了何況救別人？XD 但也許也是因為這樣，現在每當看到一些有需要的人時，就會想到以前自己是如何受人幫助，便會不自主地伸出手。 並不是說自己有多偉大，但或許這些舉動可以讓這些人找到自己的路，就像當年的我一樣。 在書中也看到了，要真的居上位，不一定要踩著別人往上爬，做的『利人利己的給予者』一樣可以走到高處。","tags":["讀書心得","好書推薦"],"title":"給予 - 施比受更有福，給予的力量","type":"讀書心得","url":"/read/give-and-take","weight":0,"wordcount":66},{"authors":null,"categories":null,"date":1650931200,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1650931200,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/","section":"tags","summary":"","tags":null,"title":"讀書心得","type":"tags","url":"/ianlife/tags/%E8%AE%80%E6%9B%B8%E5%BF%83%E5%BE%97/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1648684800,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1648684800,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/blockchain/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/blockchain/","section":"tags","summary":"","tags":null,"title":"Blockchain","type":"tags","url":"/ianlife/tags/blockchain/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1648684800,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1648684800,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/categories/tech/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/categories/tech/","section":"categories","summary":"","tags":null,"title":"TECH","type":"categories","url":"/ianlife/categories/tech/","weight":0,"wordcount":0},{"authors":null,"categories":["TECH"],"date":1648684800,"description":"Blockchain Bridge 允許了兩條不同規則、不同協議的區塊鏈將他們的數據、代幣互相傳遞。","dir":"blog/technology/blockchain/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":["crypto bridge","blochchain bridge","What is a Crypto Bridge?","What Are Blockchain Bridges"],"kind":"page","lang":"zh","lastmod":1648684800,"objectID":"26d8fc38d018080d9dcae3254fe8df59","permalink":"https://ianjustin39.github.io/ianlife/blog/technology/blockchain/blockchain-bridge/","publishdate":"2022-03-31T00:00:00Z","readingtime":1,"relpermalink":"/ianlife/blog/technology/blockchain/blockchain-bridge/","section":"blog","summary":"區塊鏈技術在近幾年來成長非常的快速，最早的 Bitcoin、Ethereum 到 Binance Chain 、 Polygon 、 Solana 等，每條鏈上都有各自的治理模式、協議、規則，甚至是 Defi、NFT、DAO 等多元化的應用也相繼出現。\n儘管近幾年出現的這麼多元的應用，但這些終究只能存在於單一條區塊鏈上，並沒有辦法與其他的區塊鏈互動，也就是說鏈與鏈之間並沒有互相操作性。每一條區塊鏈，就好比一座小島，試想在台灣的 Ian 想要跟在日本的 Justin 溝通訊息，該如何做到呢？現在的社會可以經由通訊軟體或是社群軟體，直接將訊息傳遞出去，也就是所謂 Web 2.0 的應用，同理，比特幣想要到以太坊上做應用，以現在的狀況來說，只有中心化交易所（還不能經由去中心化交易所 Dex）換成以太幣或是 ERC-20 token 才有辦法做到這件事。但若這樣操作手上便不在持有比特幣，這也跟當初想要以『比特幣在以太坊上做應用』的想法有所差異。\n什麼是 Bridges，運作原理是什麼？  先來講講什麼是 Blockchain Bridge ，它是以什麼方式來解決互相操作性的問題。Bridge 允許兩條不同規則、不同協議的區塊鏈將他們的數據、代幣互相傳遞。以上述的例子來講，可以不經由交易所得換幣服務，直接再以太坊上使用自己持有的比特幣。\n在你希望將自己的一部分比特幣轉移到以太坊上時， Blockchain Bridge 會先將你比特幣鎖在所使用的 Bridge 上，並在以太坊上建立等同價值的比特幣代幣（稱作 wBTC），此時便可以使用 wBTC 去操作以太坊上的 Dapp 。相反，當你認為不需要繼續在以太坊上，想要換回比特幣時，只需要做反向的行為，以太坊上的 wBTC 會被燒毀，而同等價值的比特幣則會回到你的手上。但必須注意的是，若用 Bridge 將 10 BTC 換成 10 wBTC，換回時卻只有 9 wBTC 的話，也只能取得 9 BTC。\n簡單來說，經由 Bridge 是將你的加密貨幣『複製』一份到別條鏈上，讓他符合另一條鏈的規範與協議，可以操作上面的各種應用。\nBridges 種類  Bridges 又分為 One-Way Bridges \u0026amp; Two-Way Bridges，以及 Trust-Based \u0026amp; Trustless Bridges。","tags":["Blockchain"],"title":"什麼是 Blockchain Bridges，運作原理是什麼?","type":"區塊鏈","url":"/ianlife/blog/technology/blockchain/blockchain-bridge/","weight":0,"wordcount":156},{"authors":null,"categories":null,"date":1648684800,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1648684800,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/series/%E5%8D%80%E5%A1%8A%E9%8F%88/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/series/%E5%8D%80%E5%A1%8A%E9%8F%88/","section":"series","summary":"","tags":null,"title":"區塊鏈","type":"series","url":"/ianlife/series/%E5%8D%80%E5%A1%8A%E9%8F%88/","weight":0,"wordcount":0},{"authors":null,"categories":["Learning"],"date":1648512000,"description":"當世界沉迷年少得志，耐心是你成功的本事","dir":"blog/learning/reading/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":["讀書心得","可複製的領導力","樊登"],"kind":"page","lang":"zh","lastmod":1648512000,"objectID":"6b0254d9d46c9e186d315a45022d7fc0","permalink":"https://ianjustin39.github.io/ianlife/read/late-bloomers/","publishdate":"2022-03-29T00:00:00Z","readingtime":1,"relpermalink":"/ianlife/read/late-bloomers/","section":"blog","summary":"1. 英雄出少年的時代  現在時常可以看到關於『三十歲以下的傑出青年榜』、『矽谷獨角獸創辦人年紀僅二十多歲』之類的新聞，大多在敘述現在的年輕人有多麼的積極，年紀輕輕就創出了一番名號、甚至改變產業，賺進鉅額的資產。而父母為了讓自己的兒女也可以『英雄出少年』，便讓小孩從小學，甚至幼稚園開始就開始補習，目的就是為了不要讓他們輸在起跑點，可以在年紀輕輕就有一番成就。\n這個文化不只影響了父母，學校教育也逐漸偏向這種風氣，比方說，如何用智力測驗篩選出菁英人才；為了讓考生可以進入菁英大學而開設的補習班等等，整個社會彷彿充斥著『你必須要在年輕時就成功，這樣才算一個成功者』的氛圍，但同時也扼殺了年輕人的潛能。為了及早成功，這些人相較以前更為疲憊、脆弱、甚至害怕失敗。為了成功，他們不在願意冒險，只想打著安全牌，這樣看似可以交出一些東西，也不會被檢討。或許這在成績、工作上可以帶來成就，但這並不一定是自己想要過的人生。\n2. 創造屬於自己的文化  如同之前講的，社會對於年輕就有成就的人給予了極大的肯定，心理學家稱這類的想法為『規範性思維』。『規範性思維』有幾個缺點，首先大部分的人都認為『多數人的選擇』才是正確的選擇，像是『大家都考大學，所以我也要跟著考大學』一樣。第二個壞處在於，會無止盡的『有害比較』，如哪間大學畢業、薪水多少、職業是什麼等。如果自己沒有遵從這規範性思維，就會被社會排擠、被認為是異類。不過也有成功人士，在年輕時默默無聞，經歷了一番歷練後才有所成就， 如漫威（Marvel）教父史丹．李（Stan Lee）40多歲創立自己的漫畫世界、張忠謀 56 歲創立台積電、肯德基爺爺哈倫德 65 歲才創肯德基。\n若當下的自己還沒有，或是沒辦法發揮自己的潛能，或許可以看看現今社會對文化的影響，可能不是你不夠好，只是你被現今的社會文化所束縛了。一定得進 google 才算成功嗎？自己開一間餐館或許是更好的選擇。\n3. 學會放棄，探索更多可能  成功的秘訣在於堅忍不拔，克服重重困難。在這個社會，放棄是被忽略的選項甚至是被禁止的事情，但堅持不懈卻幾個問題：\n  韌性以及意志是一種有限的資源：也就是自我損耗的概念，當你在堅持一件自己沒那麼相信的事，那到最後只會將你的意志力消磨殆盡而已。這就很像去重訓，最多就只能做100公斤四組，但硬要做到第五組，那結果顯而易見（但這不代表意志力可以像肌肉一樣鍛鍊）。\n  放棄反而有益健康＆常能帶來更好的結果：1970 末期 intel 因為日韓進入了記憶體市場而開始跟他們薛假競爭，這是 intel 決定要放棄記憶體市場，將未來賭在微處理器上，以現在看來這是個成功的決定，但當初並不是這麼順利，如果 intel 沒有放棄記憶體市場，現在的微處理器大廠可能就換人了。所以放棄並非失敗，放棄只是為了尋找更適合的方向。\n  4. 成長的太慢？那就尋找更好的花盆  相信大家都聽過『螃蟹心理』，當一隻螃蟹想要往上爬時，其他螃蟹會將他往下拉。有時自己想要往上爬，便會感到同溫層會將自己往下拉的力量，就如同螃蟹一樣。 不過為了自己可以有更好的發展，必須要找到適合的地方，就像每種植栽都適合不同的栽種方式，必須要找到適合的花盆，才有可能長的美麗。\n但不是說毫無計畫的更換，如果想要去國外工作，離職去當外送員似乎助力不大，或許去外商公司上班磨練，會是更好的選擇。所以在選擇花盆時，應該考慮自己的目標是否與花盆契合，轉換後是否可以讓自己更專心、認真、更全心投入，讓整體表現都比現在狀況更好。轉換的過程中也會有阻力，不管是環境或是自己，畢竟改變是痛苦的，為何我不好好待在舒適圈？不過我們應該時刻的問自己『我是不是待在最能讓我發光發熱的花盆內？』這才是最重要的事。\n5. 成功沒有期限  在資訊爆發的年代，很多團體或是公司橫空出世，大家所認為的『一夕爆紅』、『一夜至富』的背後，其實是十幾年、甚至二三十年的堅持，才能活得的結果。諸多大器晚成的人都表示，只要找到屬於自己的花盆，就要努力堅持下去。\n讀後心得  在這網路發達的時代，社群媒體、新聞上充斥著各種的年輕創業家，短短幾年內把自己的產品打造成獨角獸的故事。讓社會漸漸的覺得『如果沒有年紀輕輕有一番作為，那一定沒辦法成功』。當然這個觀念也深深影響到了我，曾經的我也認爲需要在年輕時有一番作為，不管年薪達到一個門檻，或是當上某間公司的主管，就是一個成功者。這也讓我在追逐著這『自以為的成功』的過程中付出了不小的代價。\n這本書説是為大器晚成的人抱不平，但其實我認為他想傳遞的思想是『跳脫社會主流的價值觀，活出自己想要的樣子』。或許每個人都要思考一下，自己有限的人生中，想要成為什麼樣子的人？社會定義的文化並非適用於每個人，也不是一個必須遵守的法則。耐心尋找屬於自己的路，走出自己的人生才是最重要的。","tags":["讀書心得","好書推薦"],"title":"大器可以晚成","type":"讀書心得","url":"/read/late-bloomers","weight":0,"wordcount":39},{"authors":null,"categories":["Learning"],"date":1642982400,"description":" 成為領袖之前，成功就是讓自己成長。成為領袖之後，成功是讓別人成長。——美國商業領袖傑克-韋爾奇","dir":"blog/learning/reading/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":["讀書心得","可複製的領導力","樊登"],"kind":"page","lang":"zh","lastmod":1642982400,"objectID":"62b2669f2f2825293d7f9102bcf1098f","permalink":"https://ianjustin39.github.io/ianlife/read/reproducible-leadership/","publishdate":"2022-01-24T00:00:00Z","readingtime":1,"relpermalink":"/ianlife/read/reproducible-leadership/","section":"blog","summary":"管理者的定位是什麼？  管理者的任務是打造有戰鬥力團隊，而不是什麼事都親力親為，一個能力好管理者，除了帶領團隊達成目標以外，同時也能培養出有能力的人才。\n透過別人完成任務 當從一名職員升職成一名管理者，所需承擔的責任也從『完成被交付的任務』變為『讓團隊完成任務』。 就算曾經是一名超級員工，也不太可能一個人囊括所有的任務，所以如何讓『透過別人完成任務』就是管理者很重要的課題。\n給部屬嘗試錯誤的空間 要培養一個健康且強大的團隊，就必須激發員工的各種潛能。這過程中不可避免會有些錯誤，經歷了這些錯誤才可以不斷地成長。\n船長的責任 團隊好比一艘船，每個船員在這艘船上都有各自的任務該做。一艘小船，船長可以自己執行所有任務來駕駛這艘船， 但若是一艘大船，船長的任務就不在是駕駛船隻，而是需要掌握船的方向、速度以及安全。 管理者同理，隨著團隊的擴張，管理者需要奠定策略，組織員工達成任務。\n用目標管理，降低主觀影響  在團隊中，我們需要讓員工知道，到底公司或團隊想要做到什麼事？目標是什麼？究竟為了什麼而努力？ 而目標管理與目標一樣重要，目標管理會因為團隊中各層級的不同，對於各自任務的目標設置也會有所不同。\n用目標管理也可以屏除管理者的主觀意識，可以很客觀的評斷每一位員工是否有達到各自設置的目標。 同時管理者也要思考，給予員工的目標是否合理、明確、可量化。\n可參考此篇SMART法則，讓目標變得更容易\n溝通視窗的四個象限  溝通視窗，也稱周哈里窗，是一種溝通的技巧與理論。其中又分為以下四個象限：\n隱私窗格：正面溝通，避免誤解 顧名思義，隱私就是隱僻、不公開的私事。但在隱私窗格內，分為三個階層，從不能公開到部分公開，\n 第一層：不能說  又稱為『 Deep Dark Secret 』，每個人都有 DDS ，但如果一個人有過多的 DDS，則會承受龐大的精神壓力。 在日常生活中，不打聽別人的隱私，給予對方一些空間，這是基本禮儀。 但在工作中，沒有必要有太多 DDS，不然會讓人整天活在焦慮與壓力之下。\n第二層：不好意思說  有時在工作上，員工犯錯時，本來應該給予嚴厲的懲罰，但當員工一臉緊張的到你面前時，當下又會動了惻隱之心。 這在職場上很常見，因為管理者『不好意思說』，該被糾正的問題沒有被糾正，下一次造成更嚴重的問題。\n第三層：忘了說  『忘了說』比不好意思說更嚴重，『忘了說』指的是，管理者誤以為大家都應該知道這些是，不需要再多講，但這往往是管理者的一廂情願。 這是團隊中最應該被重視的一點，又被稱『知識的詛咒』。\n知識的詛咒：當我們對某件事非常了解，腦中存有非常多的專業知識時，就會轉換表達方式， 以致說出來的東西，別人聽不懂或是難以理解，自己卻以為已經說得很明確了。   如何破解知識的詛咒  知識的詛咒，是行銷中很重要的改念，可以看看這一篇 舒利茲啤酒的由來 ，了解行銷大師霍普金斯如何破解知識的詛咒，讓舒利茲大賣。\n盲點窗格：利用回饋，看到自身侷限 盲點窗格，就是自己不知道，但別人知道的部分。盲點窗格有點類似汽車的視覺死角，所以需要後照鏡來輔助，試想如果開車或停車時， 後照鏡被拔掉了，駕駛沒辦法經由後照鏡看到視線死角，是否整個過程都會一路上都會感到焦慮？ 就如同自身的盲點窗格，若是越大，自己則會覺得越危險。\n 如何改善盲點窗格  若有人願意提出自己的缺點時，先想想是否確實擁有這個問題，以及是否為盲點窗格。 投訴以及回饋的機制也是可以讓自己知道自身盲點窗格的方法之一。\n潛能窗格：不要輕視每一名員工的潛能 每個員工都有巨大的潛能，作為管理者，應該要克服自己的主觀偏見，以一個標準化的流程，讓每個員工有公平競爭的機會。 其中管理者也比需思考以下兩件事：\n 是否充分調動了員工的積極性？ 是否為員工能力的提升提供了好的規劃與培訓？  公開窗格：讓員工尊重你，而不是懼怕你 大家都知道的資訊，如姓名、性別等，這都屬於公開窗格的資訊。它的好處的就具有社會影響力，讓人們產生信任感，如明星代言產品。 但壞處則是少了隱私，需要時刻預防偷拍、防止負面新聞流出等。","tags":["讀書心得"],"title":"可複製的領導力：樊登的九堂商業課","type":"讀書心得","url":"/read/reproducible-leadership","weight":0,"wordcount":107},{"authors":null,"categories":["TECH"],"date":1633910400,"description":"DOT is the native token of the Polkadot network in a similar way that BTC is the native token of Bitcoin or ether is the native token of the Ethereum blockchain.","dir":"blog/technology/blockchain/","expirydate":-62135596800,"fuzzywordcount":1500,"keywords":["Polkadot","Polkadot transaction","Polkadot payload"],"kind":"page","lang":"zh","lastmod":1633910400,"objectID":"03f026eaab87538bdf72f9f3b1152b94","permalink":"https://ianjustin39.github.io/ianlife/blog/technology/blockchain/polkadot/","publishdate":"2021-10-11T00:00:00Z","readingtime":7,"relpermalink":"/ianlife/blog/technology/blockchain/polkadot/","section":"blog","summary":"What is DOT? DOT is the native token of the Polkadot network in a similar way that BTC is the native token of Bitcoin or ether is the native token of the Ethereum blockchain.\nThe smallest unit of account in a Substrate network (Polkadot, Kusama, etc.) is the Planck. Kusama tokens (KSM) are equal to 1e12 Planck, and Polkadot mainnet DOT are equal to 1e10 Planck.\n1 Dot (DOT) = 10000000000 Planck","tags":["Blockchain"],"title":"Polkadot Parse","type":"區塊鏈","url":"/ianlife/blog/technology/blockchain/polkadot/","weight":0,"wordcount":1480},{"authors":null,"categories":["TECH"],"date":1628121600,"description":"The Internet of Blockchains.","dir":"blog/technology/blockchain/","expirydate":-62135596800,"fuzzywordcount":3100,"keywords":["Cosmos","Cosmos transaction","Cosmos payload"],"kind":"page","lang":"zh","lastmod":1628121600,"objectID":"e9b06bca2c552fca003c6fa202dc31b4","permalink":"https://ianjustin39.github.io/ianlife/blog/technology/blockchain/cosmos/","publishdate":"2021-08-05T00:00:00Z","readingtime":15,"relpermalink":"/ianlife/blog/technology/blockchain/cosmos/","section":"blog","summary":"圖片來源\nTransaction protobuf prefix  msgSend msgSend/amount tx single mode  enum SignMode { // SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be  // rejected  SIGN_MODE_UNSPECIFIED = 0; // SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is  // verified with raw bytes from Tx  SIGN_MODE_DIRECT = 1; // SIGN_MODE_TEXTUAL is a future signing mode that will verify some  // human-readable textual representation on top of the binary representation  // from SIGN_MODE_DIRECT  SIGN_MODE_TEXTUAL = 2; // SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses  // Amino JSON and will be removed in the future  SIGN_MODE_LEGACY_AMINO_JSON = 127; } Send - msgSend: { from_address: \u0026#39;cosmos1fnk3lxlks7tdg6x55ynv6vggtnd73ycqsq89sl\u0026#39;, to_address: \u0026#39;cosmos1hllwcqg3yz5mgx0cplh82l23ad8658dvphvjtl\u0026#39;, amount: [ { denom: \u0026#39;uatom\u0026#39;, amount: \u0026#39;10000\u0026#39; } ] } **- msgSend protobuf: (0a2d636f736d6f7331666e6b336c786c6b733774646736783535796e7636766767746e64373379637173713839736c122d636f736d6f7331686c6c7763716733797a356d67783063706c6838326c323361643836353864767068766a746c1a0e0a057561746f6d12053130303030)** from_address | 00001 010 | 0a 2d 636f736d6f7331666e6b336c786c6b733774646736783535796e7636766767746e64373379637173713839736c to_address | 00010 010 | 12 2d 636f736d6f7331686c6c7763716733797a356d67783063706c6838326c323361643836353864767068766a746c amount | 00011 010 | 1a 0e denom | 00001 010 | 0a 05 7561746f6d amount | 00010 010 | 12 05 3130303030 --- - signerInfo: SignerInfo { public_key: Any { type_url: \u0026#39;/cosmos.","tags":["Blockchain"],"title":"Cosmos transaction parse","type":"區塊鏈","url":"/ianlife/blog/technology/blockchain/cosmos/","weight":0,"wordcount":3085},{"authors":null,"categories":["Learning"],"date":1627084800,"description":"寫一篇好文章，可以重複銷售自己的時間與價值，讓人生複利成長。","dir":"blog/learning/reading/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":["讀書心得","大人的11堂寫作課"],"kind":"page","lang":"zh","lastmod":1627084800,"objectID":"bda4df616aba2e173ce18b3d18503ae1","permalink":"https://ianjustin39.github.io/ianlife/read/11-writing-lesson/","publishdate":"2021-07-24T00:00:00Z","readingtime":1,"relpermalink":"/ianlife/read/11-writing-lesson/","section":"blog","summary":"為什麼要寫作？  寫作可以重複銷售自己的時間  一個人最簡單的商業模式，就是販售時間，比方說：上班就是把自己的時間賣給老闆賺取薪水。 而在這模式中，又可分為三種類型，同一份時間出售一次、重複出售同一份時間、購買他人的時間再出售。 絕大多數的人都是第一種，少部分是第三種。而我們則可以靠自身優化從第一種進化成第二種。\n舉個簡單的例子，今天要分享故事，與多人分享的效率一定比只跟一個人講高。 但如果另一群人要聽，又要再講一次，等於要再花一次的時間。 是把演講的內容寫成一篇完整的文章，今天會有人看，明天也會有人看，甚至一年後也會有人看。 但並不需要再花時間做一次演講，這就是將時間重複銷售。\n寫的爛才要開始寫 『我覺得我寫的很爛，等進步了我在開始寫』，這是多數人不敢開始寫作的理由。但應該是因為寫的差，所以要從現在開始練習寫。 想想我們在做任何改變或是學習之前，應該都有『我這方面就是比較差，所以要開始練習』的認知，寫作也一樣， 應該是『我覺得我寫不好，所以現在要開始練習寫作』。 所以如何踏出寫作的第一步。就是先認清『自己暫時寫的差』的這個事實。\n先寫好一段話 寫作的第一步，並不是寫長篇文章，而是先寫好一段話。比方說從『無限賽局』中學到了什麼事有限思維以及無限思維， 一開始就要寫一篇關於無限思維的文章困難度非常高，但可以先從一段文字開始，試著用幾句話向別人解釋什麼是無限思維。 『原子習慣』一書中提到『最小努力原則』，意思是讓習慣簡單到就算沒意願也會執行，難度越低，執行起來越容易。 比方說，今天看完一部電影，要直接寫出影評太困難，但可以先寫 50~100 字的觀後心得。 持續練習下來會發現，300~400 的文章已經可以輕鬆地寫出來，直到有一天就可以寫出一篇完整的觀後影評。\n寫作的核心：輸入、思考、輸出  寫作不外乎就是，想到東西、整理思緒、寫下來。看似簡單的幾個動作，其中卻有不簡單的道理。 例如：\n 想寫一篇政治的文章，但一個沒看過新聞的人，怎麼寫得出來呢？『輸入』的重要性。 平時常常在看新聞，但只是邊看邊跟著罵政府，那能寫出什麼東西呢？『思考』的重要性。 平時都有看新聞，也有經過獨立思考了，終於拿起筆，但卻不知道要寫什麼，該怎麼辦？『輸出』能力。  接下來接著深入探討如何有效的『輸入』、『思考』、『輸出』。\n輸入 要長期且穩定有高品質的輸出，就需要不斷的接收新資訊、新觀點，所以輸入的方法就很重要，可以用以下三種方法來提升我們輸入的能力。\n 強度：『沒數量就沒品質』，兩人能力相當的情況下，一年讀五百萬字和一年五十萬字的人，寫作能力就會有極大的差距。 標準：『8 星 \u0026gt; 6 星』，寧可多花一些時間去查詢評價，也不要直接去看一部沒什麼重點的爛片（不一定是影集）。 效果：『吸收 \u0026gt; 完成』，完成不是重點，重點是有沒有吸收。比方說同樣是讀書，有的人目標是『讀完』，有的人目標是『將書中的知識運用在工作上』。  思考 必須要將輸入的資訊整理清楚，才有辦法有效的輸出成文字，\n 追問：不管遇到什麼問題，都要有追根究底的精神。 建立連結：試著將學到的知識互相建立關係。例如：從寫好一句話開始 -\u0026gt; 原子習慣中的『最小努力原則』。 應用：將所學的東西實際應用出來。  輸出 有不斷的輸入、不斷的思考，最後就是如何把素材輸出成一篇文章，作者提供了以下四種方法來練習寫作：\n 就是寫：就是不會，才要『刻意練習』。如同開頭講的，可以從一段話開始慢慢練習。 學寫故事、觀點：故事及觀點可以讓我們思考文章如何呈現給讀者，讀者才會買單。 建立寫作流程：寫作也是需要流程的，選題、找素材、擬稿、成搞\u0026hellip;等，因人而異。 建立回饋系統：不管做任何事，回饋機制很重要，有回饋才有辦法改進，才能不斷的進步。  五個切入點寫出好文章  主題：對這世界要有點意見 一篇好的文章，主題很重要。作者認為我們應該『對這世界要有點意見』，多發表自己的觀點，用自己的思路去思考每件事。再來主題應該要可以覆蓋多數人群，打到大部分人的痛點，可以參考人生金字塔的五個階層。\n題目：抓住眼球 好的題目可以讓讀者一眼看下去，就有『這就是我要找的』感覺。。這裡也可以參考剛剛提到的人生金字塔來擬定題目。 作者認為，好的標題包含三個因素：","tags":["讀書心得"],"title":"大人的11堂寫作課 - 複利成長自身的價值","type":"讀書心得","url":"/read/11-writing-lesson","weight":0,"wordcount":91},{"authors":null,"categories":["Learning"],"date":1624752000,"description":"說書，是將書本的知識『再傳遞』，如果有辦法有效的說書，那也代表自己可以有效的掌握了這本書。","dir":"blog/learning/reading/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":["讀書心得","讀懂一本書"],"kind":"page","lang":"zh","lastmod":1624752000,"objectID":"8606ff3881830ca263917e05db6fa2ca","permalink":"https://ianjustin39.github.io/ianlife/read/understand-a-book/","publishdate":"2021-06-27T00:00:00Z","readingtime":1,"relpermalink":"/ianlife/read/understand-a-book/","section":"blog","summary":"在開始讀書之後，讓我開啟了廣大的視野，但如何將書本的東西有效的吸收內化， 甚至可以將書本的內容有效的分享給別人，也是我現階段重要的課題， 如果能有效的『再傳遞』書本內的知識，那也就代表我真的掌握到這本書所想傳遞的精神，真正的『讀懂一本書』。\n閱讀是『反脆弱』的武器  什麼是脆弱？就像玻璃杯從桌上掉落，就被摔碎一樣。 相反就是堅固？比方說換成鐵球，就不會與玻璃杯有一樣的下場。 若是再換換成乒乓球，那它掉到地上就會馬上彈起來。\n在『反脆弱』一書中，作者認為脆弱的相反不是堅固而是反脆弱，如同乒乓球，不管怎樣用不良、負面的事件去影響，它不僅不會壞，反而會更強大、更優異。 在現實中，脆弱代表著怕變動、怕跳戰、面對突如其來的事件會遭遇損害；而堅固則是面對突如其來的事件，對它來說什麼都不會影響及改變；反脆弱則代表者勇於接受變動、挑戰，越多刺激，那自身能力就會越進步。\n為什麼閱讀是反脆弱的武器呢？因為閱讀有兩個特點， 第一點是『主動性』：讀書是主動的學習，我們所讀一定是我們所需要的，這可以彌補自身知識的不足。 第二點是『針對性』：讀書所帶來的收穫因人而異，莎士比亞說『一千個讀者，就會有一千個哈姆雷特』。每個人會因為尋找符合自身個性化的領域吸收加強。\n當掌握這兩點，遇到變動或是挑戰時，不會再像玻璃杯一樣一摔就破，而是有辦法去適應這些事件，讓自己越來越強大。\n為知識鬆綁，會讀書也要會說書  為什麼會認為閱讀是痛苦的，因為我們認為閱讀的成效不如我們的預期。就像去下定決心要減肥，但發現鏡子裡的自己好像沒有瘦，得不到成就感，最後只好選擇放棄。\n說書，是將書本的知識『再傳遞』，如果有辦法有效的講書，那也代表自己可以有效的掌握了這本書。要更有效的說書，在閱讀時我們必須不斷的問自己三個問題：\n 我能不能準確把握這本書真正的含義，理解這本書？ 我能不能用自己的語言，清楚表達出這本書的真正含義？我的資訊效度和信度如何？ 我表達出來的內容能不能讓沒讀過這本書的人無障礙理解？我的語言是否通俗易懂，能夠被二次傳播？  每次閱讀帶著這三個問題，先說服自己，才有辦法傳遞給他人。 如同我們工作上網查資料，必須先篩選適合的資料，並過濾出有效的資訊，接著解讀、思考是否有符合我們需求的資訊、最後再將其驗證。\n一般人的劃線重點 v.s. 說書人的劃線重點  究竟書中的名言佳句是不是重點，我們會在閱讀時畫下『我們認為』重要的句子，可能是某個偉人的名言佳句、又或者是讓我們有深刻體悟的一段話。 樊登認為這是非常關鍵的一個問題，所以總結了以下八個評判標準：\n1. 當你感覺概念被清楚界定時 如同一開始提到反脆弱所舉的例子，玻璃杯、鐵球、乒乓球間所代表的差異性。\n2. 當你感覺問題很嚴重時 如果自己都沒覺得嚴重，那怎麼說服他人。像之前讀到的『為了遇見40歲更好的自己』中有提到，我們總是想要做很多事，發現每件事都有做，但每件事都沒達成目標。 因為人類大腦無法同時判斷多組情報，因此三種左右是最適當的數量。過去我也曾經有這個煩惱，這本書所提到的這個面相讓我有深刻的體驗，也感受到這個問題的嚴重。\n3. 當你感覺某種解釋令你很意外時 抽菸者要戒菸普羅大眾認為要靠毅力，直到樊登朋友因為一本『這書能讓你戒菸』，而成功戒菸，讓他對於戒菸的印象有個改變。 因為書中提到，如果淺意識內認為抽煙是好的，就算再有毅力都不會成功。 戒菸應該靠對吸菸的『認知』，要知道吸菸對於身體或是周遭的人所產生傷害，才有辦法從根本上戒除。\n4. 當你看出遞進關係時 樊登提到他在講『世界觀』這本書時，無法略過第谷，因為第谷提供全套的觀測結果，所以克普勒提出第一定律及第二定律，接著牛頓則算出橢圓形上的週期運動，這就是一步步的遞進關係。\n5. 當你看出轉折關係時，要留意轉折後的內容 閱讀到書中的轉捩點，或是讀到觀感上的反轉，這也是很重要的部分。\n6. 不同面向彰顯書籍內的價值 有的書結構是遞進；有的則是先提出主題，再用不同面向的去驗證這個主題。我認為我看過的書中『原子習慣』是遞進，而無限賽局則是『提出主題』。\n『原子習慣』一書中，先定義習慣的對我們的影響多大，在從頭開始述說我們要怎麼去建立一個原子習慣。 『無限賽局』則是先定義無限以及有限定義出來，再經由幾個面向去解釋驗證無限思維的重要。\n7. 閱讀受到心靈衝擊 在『無限賽局』一書中提到，無限思維與有限思維的差異讓我有深刻的體會。\n8. 書中的奇聞趣事，增添說書的趣味性 記下一些書中提到有趣的故事，可以在說書時分享，讓過程更有趣。\n讀後心得  在開始閱讀之後，時不時會與幾個朋友聚再一起分享閱讀的書籍，雖然每次都有寫下書本摘要及心得，但總感覺無法有效的將書中的知識做傳遞。 最初選這本書的原因只是希望自己可以真正的將書本內的知識吸收，並有效的轉換成文字或是言語分享給其他人，但讀完之後給我的啟發已經遠超過當初的期待。 從為什麼要閱讀、如何讀懂一本書、如何抓取書中的重點知識、說書其實是再創作、運用心智圖說書\u0026hellip;等等，對我來說都非常的有幫助。\n我滿喜歡書中提到的一點『理解的池子有多大，就能讀懂多難的書』。如果連三角函數都不會，怎麼去學微積分，唯有不段的充實自己，才有更多的可能性。","tags":["讀書心得","好書推薦"],"title":"讀懂一本書 - 從讀書到說書","type":"讀書心得","url":"/read/understand-a-book","weight":0,"wordcount":60},{"authors":null,"categories":null,"date":1623801600,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1623801600,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/ethereum/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/ethereum/","section":"tags","summary":"","tags":null,"title":"Ethereum","type":"tags","url":"/ianlife/tags/ethereum/","weight":0,"wordcount":0},{"authors":null,"categories":["TECH"],"date":1623801600,"description":"Ethereum London Hard Fork （倫敦硬分叉）所做的更新，包含了 EIP-1559、EIP-3198、EIP-3238 三個提案，其中 EIP-1559 也是這次比較備受關注的部分， EIP-1559 可能會改變以太坊的交易費用模型。","dir":"blog/technology/blockchain/","expirydate":-62135596800,"fuzzywordcount":600,"keywords":["Ethereum","Ethereum London Hard Fork","London Hard Fork"],"kind":"page","lang":"zh","lastmod":1623801600,"objectID":"907b8b6dace481cf3d5d867dd69a5a65","permalink":"https://ianjustin39.github.io/ianlife/blog/technology/blockchain/ethereum-london-hard-fork/","publishdate":"2021-06-16T00:00:00Z","readingtime":3,"relpermalink":"/ianlife/blog/technology/blockchain/ethereum-london-hard-fork/","section":"blog","summary":"前言  現今以太坊的手續費過於昂貴，交易者需要付出高額的手續費才可以完成交易。 這次的 Ethereum London Hard Fork （倫敦硬分叉）所做的更新，包含了 EIP-1559、EIP-3198、EIP-3238 三個提案， 其中 EIP-1559 也是這次比較備受關注的部分。\nEIP 是什麼？  EIP(Ethereum Improvement Proposals)，是為以太坊指定潛在新功能或流程的標準，包含提議更改的技術規範。通過 EIP 流程討論和開發以太坊的網絡升級和應用標準。\n提案一： EIP-1559（區塊鏈交易費用模型）  EIP-1559 是對用戶在以太坊網絡上支付 gas 費用方式的更改。（由於現在以太坊交易手續費過高，降低對用戶的吸引力）\n 以往：礦工可以賺的收入「挖礦獎勵」跟「 100% Gas fee 」 EIP 1559 ： gas fee 分為基礎費（base fee）和小費兩種，給礦工的是「小費」； base fee 的 50% 會直接銷毀。  EIP-1559 也導入目標塊容量機制，每個區塊的基本費用根據網絡需求而變化。如果一個區塊的交易量超過 50%，則基本費用將增加，低於 50% 的話基本費則會下降。 而基本費可能會隨著交易加入 block 時發生改變，可以先將 price 設定成願意支付的上限，最後沒用到的部分會退還。\n這個提案重點在於基本費會被銷毀，並不會所有的 gas fee 都讓礦工拿走。而也藉由『銷毀』機制，讓以太幣的供應量下降，避免通貨膨脹。\n交易格式的差異 以下部分段程式碼是從 EIP-1559 擷取。\n新交易格式內的 base_fee_per_gas ＆ priority_fee_per_gas 取代了以往的 Legacy Ethereum transactions 的 gas_price。 但 EIP-1559 可以相容 Legacy Ethereum transactions 的格式。 雖然現有的交易格式仍然有效且也被包含在 block 中，不過 Legacy transactions 沒辦法享有新的 pricing system 所帶來的優點。","tags":["Blockchain","Ethereum"],"title":"無視礦工，以太坊的倫敦硬分叉","type":"區塊鏈","url":"/ianlife/blog/technology/blockchain/ethereum-london-hard-fork/","weight":0,"wordcount":564},{"authors":null,"categories":["Learning"],"date":1621036800,"description":"跳脫勝負、平手、僵局之外，看懂自己身處的賽局，才能選對策略、創造最大價值。","dir":"blog/learning/reading/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":["讀書心得","無限賽局"],"kind":"page","lang":"zh","lastmod":1621036800,"objectID":"8369d642924fd23d3c0e0f90640c8db6","permalink":"https://ianjustin39.github.io/ianlife/read/game-the-infinite-game/","publishdate":"2021-05-15T00:00:00Z","readingtime":1,"relpermalink":"/ianlife/read/game-the-infinite-game/","section":"blog","summary":"\n沒有開始、中場以及結束的賽局  想想從小到大，我們經歷了許多賽局，像是體育競賽，有已知的玩家，既定的規則。在達成目標，也就是誰的比分先到標準，該隊伍就會獲勝，賽局就會結束。 相較於競技比賽的『有限賽局』。『無限賽局』中並沒有時間限制、沒有終點線、沒有真正的結束，像是商場上會不斷的有新玩家加入，沒有既定的規則，大家會依照自己的方式衍生出商業模式，試著一直存活在這場賽局內。\n從微軟與蘋果間的戰爭看待商業賽局  微軟本來的願景，是為了提高生產力，幫助地球每個人到組織，可以貢獻更多，成就更大。但到了近幾年，公司的目標逐漸轉向『打贏競爭者』，也就是打贏蘋果。 作者曾經受邀在微軟以及蘋果的教育高峰論壇上演講。在微軟的論壇中，多數的講者都會提到如何打敗蘋果；而在蘋果的論壇內，講者都花時間在討論蘋果如何幫助老師教學、幫助學生學習。\n打敗蘋果事現在微軟的目標，所以微軟的產品都以『性能需要比蘋果強』為出發點思考；反之蘋果則是思考如何達到公司願景，創造更好的產品來滿足大眾的需求，並且可以不段的創新突破，這樣的信念也進而改變了市場的結構。\n無限思維的五個關鍵  如何從有限思維的框架中跳脫出去，進而有無限思維呢？作者提供了五個關鍵給我們\n崇高的信念 崇高的信念是對一個尚不存在的未來懷抱具體的願景；這個未來令人嚮往到人們願意犧牲小我，來實現這個願景。  『隨時隨地以最低的價格來服務美國廣大的勞工』，這是美國零售業沃爾瑪的企業願景。其創辦人沃爾頓秉持著這個信念經營，在經濟大蕭條時成為了最富有的人之一。 但就算這樣，沃爾瑪也有背離信念的時候。接任執行長杜克上任後，將公司目標轉向利潤、成長以及市場地位，服務的對象以股東為首，不在是美國勞工。這也造就了後續沃爾瑪的各種負面新聞。直到明倫接任杜克之後，才重拾沃爾瑪的信念，將公司帶回無限賽局內。\n信念不像目標，達成就結束，而是會一直持續下去。若公司的不在以信念為核心推廣業務，反而只在乎獲利、報酬，長久下來會脫離原本的軌道，也無法進步。\n彼此信任的團隊 領導者要負責的不是結果，領導者要負責的是要對結果負責的人們。  組織文化、環境關係到一個團隊的是否可以高效率的執行作業。 許多公司現在提倡組織扁平，每個員工都可以為了公司、產品提出自己的見解，讓資訊流通暢行無阻。 而領導者的責任就是維持這個組織的文化，提升成員對團隊的信任程度，讓員工發揮最佳的表現。\n『有限思維』的領導者關注『結果』、『績效』，想著如何壓榨員工，讓他們達到自己預期的成果； 『無限思維』的領導者則是關注團隊的『環境』、解決問題的『過程』，遇到問題時大家是否可以適時的提出自己的意見，並一起解決眼前的問題。\n可敬的對手 傳統思維讓我們採取要獲勝的態度，敬畏對手的思維則啟發我們採取改進的態度  『成為第一』、『打敗對手』內心總是想著如何讓對手退出賽局，傳統的思維讓我們侷限在只能『獲勝』的層次。 或許仔細思考，可以發現因為對手所擅長的事自己並不擅長，但我們卻不願意面對，轉而將精神放在如何擊敗他的上面？ 擁有『無限思維』的人為認為，可敬的對手指出了自身的不足，我們可以藉由向對方學習，不斷的提升自己，讓自己不斷的朝『崇高的信念』邁進。\n『有限思維』的人關注『結果』，想著如何才可以打敗對手； 『無限思維』的人關注改變的『過程』，改變讓自己更接近『崇高的信念』。\n攸關存亡的應變 攸關存亡的應變是為了更有效地推動信念，即使這麼做會顛覆現有的商業模式。  以往的商業模式可以賺大錢，但套用在現今或許不在實用，可以從柯達這間公司來思考。\n『像鉛筆一樣簡單。你俺快門，剩下的交給我們。』這是柯達的廣告詞。 柯達的底片佔了公司大部分營收，而第一台數位相機也是柯達發明，但為什麼柯達最後還是敗在數位相機？\n柯達的領導者認為，數位相機這項產品，與自家的底片有衝突，如果就這樣發表出去，可能會影響到公司的營收。 最後領導者認為底片才是賺錢的來源，而數位相機會讓賣出的底片變少，所以選擇不發表這項產品。 十年後 Nikon 發表第一台數位相機，而柯達到最後也退出了這場賽局。\n『有限思維』的人關注『短期獲利』，只想著怎麼樣才可以賺錢，而忽略了自身的信念； 『無限思維』的人關注『推動信念』，攸關存亡的應變為了更推動『崇高的信念』，即使推翻現有的商業模式。\n領導的勇氣 正值不只是做對的事，正直是在大眾抗議或醜聞發生之前就採取行動。 當領導這知道公司明明在做不道德的事，卻等輿論爆發之後才採取行動，這不是正直，這叫損害控制。  2014 年，美國最大的連鎖藥局 CVS 宣布停售香煙及菸草，這項決定並沒有人去要求 CVS ，也並非任何負面消息，縱使這項決定會使他們每年損失二十億美元。 CVS 的領導者用『信念』來引導公司業務，而這項決定也讓有使命感的公司去跟他們合作，開啟了 CVS 在保健食品這塊領域的商機，也提升了公司的形象。 反觀競爭對手，只高喊帶給世人健康的信念，而沒有勇氣做出改變的決定。\n限時的無限賽局  或許『信念』才是『無限思維』根本，蘋果的信念是創新，微軟的信念是激發大家的生產力，『崇高的信念』造就了這些偉大的公司。 當信念轉變成利益導向，如同微軟不在思考怎麼讓大家發揮價值，而把目標轉向打贏蘋果，此時陷入有限思維的微軟，如同丟掉武器赤手空拳的來對抗競爭者，對於蘋果的競爭力也不在像以前那麼高。\n人生本是一場『無限賽局』，但我們僅擁有有限的時間，我們要用『無限思維』去看待這場『限時的賽局』。崇高的信念可以讓思維跳脫輸贏\u0008，可以犯錯、可以推翻現況，就是為了更接近人生的信念；擁有可敬的對手讓我們不在只在乎表面的輸贏，而是成為互相檢視的導師，推動自己不斷的向前邁進。當我們不在以『我』為中心來思考任何事，而是將眼光放遠，以信念來引導我們的方向，勢必可以創造屬於自己的價值，並影響更多的人。\n🔅 原子習慣：一旦你發現『時間』才是最寶貴的貨幣，你會徹底改變你的生活風格和習慣。  SlideShare   顯示簡報   Game the infinite game  from Ian Tsai  ","tags":["讀書心得","好書推薦"],"title":"無限賽局 - 『永續』還是『取勝』？","type":"讀書心得","url":"/read/game-the-infinite-game","weight":0,"wordcount":69},{"authors":null,"categories":["Learning"],"date":1616284800,"description":"超速學習的定義為『一種獲取技能與知識的策略，兼具自主性與高強度。』","dir":"blog/learning/reading/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":["讀書心得","超速學習","ultralearning"],"kind":"page","lang":"zh","lastmod":1616284800,"objectID":"39f7a184e4cbf0beaac2eca78090f86d","permalink":"https://ianjustin39.github.io/ianlife/read/ultralearning/","publishdate":"2021-03-21T00:00:00Z","readingtime":1,"relpermalink":"/ianlife/read/ultralearning/","section":"blog","summary":"如何成為超速學習者？  超速學習並非千篇一律的方法，每個人的學習計畫都是獨特的，而要到達的精通程度所需的方法也不同。這本書中整理出了九個普遍的法則基礎，並稱這套方法為超速學習。\n後設學習、專心致志、直接學習、反覆練習、提取記憶、意見回饋、保留記憶、培養直覺、勇於實驗\n建立學習地圖  超速學習的第一步為『後設學習』，後設學習在這本書中指的是學習關於學習這件事。比方說，只會英語者以及會西班牙語加英語的雙語者同時學法語課。後續追中顯示，雙語者表現會優於單語者。\n為什麼？因為西班牙語以及法語都是羅馬語系，因此對雙語者來說是一個優勢。但其原因不只是這樣！會多種語言者可以藉由比較兩種或以上語言特中，開發出不同語言學習的策略能力。也就是所謂的『後設語言覺識』。\n而要畫出學習地圖，則要先問自己『為什麼、做什麼、怎麼做』，進而了解自己的學習目標以及方法。\n真正的學習，其實是在直接做你想變擅長的事時才會發生  回想以前考高中大學時常常聽到一句話：『若你覺得現在唸書是痛苦的，那代表你做對了，請你堅持下去。』，在我的認知裡，直接學習一項技能並不會太舒服，甚至很痛苦，例如想學一種語言，並非直接看文法、背單字或是與人對話，而是透過各種有趣的應用軟體，讓自己有種『我好像學到東西』的感覺。而 真正的學習，其實是在直接做你想變擅長的事時才會發生。 當真的要學習語言，應該思考如何做直接的可以學習到這項技能，比方說上線上真人課程與外國人溝通、每天閱讀英文報章雜誌學習新字彙\u0026hellip;等。\n在被迎面痛擊之前，每個人都有自己的一套計畫。  學習過程中，取得回饋很重要，回饋是可以評估學習成效的重要方式之一。但不見得回饋越多越好，關鍵在於得到回饋的類型。當回饋提供的是指引學習方向有用的資訊，那就會有好的效果。\u0008若是給一個個體的評價，例如：『你好棒！』或是『你好懶墮\u0026hellip;』，這並非是對學習本身的回饋，通常會對學習有負面影響。\n而回饋的不當解讀或無法給予有用的資訊，也會造成反效果。超速學習者必須留意兩種可能性：\n 對並未提供能帶來有用資訊的回饋反應過度。超速學習者必須對回饋敏感，並過濾。 如果運用不當，回饋對行動力也會有影響。過度負面會降低行動力，過度正面會阻礙進步。  勇於實驗，往舒適圈外探索  開始一項新技能時，通常只要照著比自己厲害的人去做就夠了。但隨著越學越多，只是遵循榜樣通常不再足夠，必須自己去實驗，找到屬於自己的道路。比方說一個程式設計師，一開始學寫程式時，通常都是上網找尋範本。但等到累積一定的知識量後，就不用在複製別人的範本，而是自行架設一個網站，可以藉由自行架設網站的過程中，知道哪些部分的能力還需要加強。\n費曼技巧  書中第八個法則『培養直覺』中提到了費曼技巧，讓我想起為什麼想寫文章，一方面是想要紀錄自己學了什麼，另一方面是想如果是別人看我的文章，可以理解這個東西到什麼程度、要如何將我所理解的知識傳遞給他人，若無法順利傳遞知識，代表我對於正在學習的項目還不是很了解。\n 在一張紙的最上方，寫下你想了解的觀念或問題。 在下方空間解釋那個想法，彷彿你必須傳授他人。  若是觀念，先問自己，要如何把這個觀念傳給從未聽過的人 若是問題，就說明該如何解答；重要的事，要說明你為何認為解題步驟是合理的。   當你卡住了，就代表你的理解無法提供清楚的解答，請回去找書、筆記、老師、或是參考資料，直到找出答案為止。  可以應用在三個地方：\n 你完全不了解的事物。 你似乎無法解決的問題。 為了擴展直覺。  讀後心得  超速學習在這本書中，給了滿多真實範例及方法。但他絕對不是教你如何輕鬆學習，因為超速學習的定義為『一種獲取技能與知識的策略，兼具自主性與高強度。』而在書中也點出了一些我在學習時產生的盲點，如『直接學習』。就像上面講的，往往學習新事物都是痛苦的，所以都想要用輕鬆的方式去達成學習的成果，但都忽略了最直接的學習，可以最快速了解內容，雖然過程不舒服，但累積下來的成果也將非常可觀。\n閱讀筆記  若想參考閱讀筆記，可以點 這裡 參考","tags":["讀書心得","好書推薦"],"title":"超速學習 - 『學習』從來不是一件輕鬆的事","type":"讀書心得","url":"/read/ultralearning","weight":0,"wordcount":35},{"authors":null,"categories":null,"date":1615939200,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1615939200,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/algorithm/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/algorithm/","section":"tags","summary":"","tags":null,"title":"Algorithm","type":"tags","url":"/ianlife/tags/algorithm/","weight":0,"wordcount":0},{"authors":null,"categories":["TECH"],"date":1615939200,"description":"快速排序使用分治法（Divide and conquer）策略，藉由一個基準值來把一個序列（list）分為較小（左）和較大（右）的 2 個子序列，然後遞迴地排序兩個子序列。","dir":"blog/technology/data_structures_and_algorithms/","expirydate":-62135596800,"fuzzywordcount":800,"keywords":["演算法","Algorithm","Quick Sort","快速排序法"],"kind":"page","lang":"zh","lastmod":1615939200,"objectID":"42206d43bf586b7e0f16a050be283ecb","permalink":"https://ianjustin39.github.io/ianlife/algorithms/quick-sort/","publishdate":"2021-03-17T00:00:00Z","readingtime":4,"relpermalink":"/ianlife/algorithms/quick-sort/","section":"blog","summary":"","tags":["Algorithm"],"title":"快速排序 - Quick Sort","type":"Data Structures and Algorithms","url":"algorithms/quick-sort","weight":0,"wordcount":717},{"authors":null,"categories":null,"date":1615939200,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1615939200,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/series/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/series/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/","section":"series","summary":"","tags":null,"title":"資料結構與演算法","type":"series","url":"/ianlife/series/%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E8%88%87%E6%BC%94%E7%AE%97%E6%B3%95/","weight":0,"wordcount":0},{"authors":null,"categories":["TECH"],"date":1615852800,"description":"合併排序法屬於分治法（Divide and Conquer）演算法，先把大問題拆解成小問題，解決小問題後再將小問題合併，進而解決大問題。","dir":"blog/technology/data_structures_and_algorithms/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":["演算法","Algorithm","Data Structures","Merge Sort","合併排序"],"kind":"page","lang":"zh","lastmod":1615852800,"objectID":"4f0d7f7d079e0a0843d53a726c3ad318","permalink":"https://ianjustin39.github.io/ianlife/algorithms/merge-sort/","publishdate":"2021-03-16T00:00:00Z","readingtime":2,"relpermalink":"/ianlife/algorithms/merge-sort/","section":"blog","summary":"","tags":["Algorithm"],"title":"合併排序 - Merge Sort","type":"Data Structures and Algorithms","url":"algorithms/merge-sort","weight":0,"wordcount":260},{"authors":null,"categories":["TECH"],"date":1615766400,"description":"泡沫排序是一種穩定排序演算法，不斷重複比較兩個元素，如果要最小的開頭，若前一個元素小於現在這個元素，則兩個元素位置互換，反之亦然，直到所有元素都是由小到大排序才結束。而也因為這種『小元素經由交換慢慢浮至集合頂端』，故稱作泡沫排序","dir":"blog/technology/data_structures_and_algorithms/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":["演算法","Algorithm","Data Structures","Bubble Sort","泡沫排序"],"kind":"page","lang":"zh","lastmod":1615766400,"objectID":"3965d9eadb869d54154c96cad143d464","permalink":"https://ianjustin39.github.io/ianlife/algorithms/bubble-sort/","publishdate":"2021-03-15T00:00:00Z","readingtime":1,"relpermalink":"/ianlife/algorithms/bubble-sort/","section":"blog","summary":"","tags":["Algorithm"],"title":"泡沫排序 - Bubble Sort","type":"Data Structures and Algorithms","url":"algorithms/bubble-sort","weight":0,"wordcount":210},{"authors":null,"categories":null,"date":1615680000,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1615680000,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/categories/life/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/categories/life/","section":"categories","summary":"","tags":null,"title":"LIFE","type":"categories","url":"/ianlife/categories/life/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1615680000,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1615680000,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/series/%E7%9C%8B%E9%9B%BB%E5%BD%B1%E7%9A%84%E7%9C%81%E6%80%9D/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/series/%E7%9C%8B%E9%9B%BB%E5%BD%B1%E7%9A%84%E7%9C%81%E6%80%9D/","section":"series","summary":"","tags":null,"title":"看電影的省思","type":"series","url":"/ianlife/series/%E7%9C%8B%E9%9B%BB%E5%BD%B1%E7%9A%84%E7%9C%81%E6%80%9D/","weight":0,"wordcount":0},{"authors":null,"categories":["LIFE"],"date":1615680000,"description":"不管這個世界怎麼看你，你都要相信你自己。","dir":"blog/life/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":["複身犯","plurality"],"kind":"page","lang":"zh","lastmod":1615680000,"objectID":"03c5754c533bf7b3f70140010cdc8b3c","permalink":"https://ianjustin39.github.io/ianlife/movie/plurality/","publishdate":"2021-03-14T00:00:00Z","readingtime":1,"relpermalink":"/ianlife/movie/plurality/","section":"blog","summary":"上次看電影是2019年的事（沒看天能，有理由不當低能🤣），而上次看國片更不知何時了，對於國片的記憶還停留在『大尾鱸鰻』、『總鋪師』等等賀歲片，這次剛好朋友介紹而看這部電影，起初以為是類似於人格分裂的犯罪電影，想不到劇情比我想的還要豐富，有點刷新了我對於國片既定的印象。雖然有部分沒有解釋的很到位，但對於我來說，看電影就是放鬆心情，不要太過於糾結🤣🤣🤣。\n以下心得可能有點雷，還沒看過的就先跳出囉！！\n人格的撕扯，我不是我。  『攔截記憶碼』是我對於這類電影的一個印象，但這片一次注入五個人格到單一個體的精神裡，是給演員的一大考驗。個人覺得楊祐寧把這五個人都詮釋的不錯，畢竟一次演兩個人就已經不是一件簡單的事了，更何況是五個人。而在這五個人存在於意識裡的空間，是與現實相同的實驗室，表示就算你們逃出了現實的實驗室，在意識裡面還是被關起來的。如果某一個人格想要驅動 193 的身體，就需要找到一個紅門，這個紅門，象徵著 193 與女兒講的『怪角鹿』的故事，那隻鹿為了面對自己而穿過的紅門。\n張榕容飾演的科學家沈宜玲，竭盡自己的所學，為了小孩，不放棄所有可能找到他的線索，體現出一個母親，可以為自己的孩子付出一切。故事的最後，意外的反轉，193 並不是許明哲，而真的許明哲，為了奪取身體而模仿甚至策劃抹殺所有人的意識，一種『我不是我，那我是誰』的感覺。\n整部下來印象最深刻的一句話還是公車司機邱俊生的：我只是想看我阿嬤啊\n觀後的省思  世界友善對待先天有缺陷的人並不友善 想起以前學生時代，大家對於一些行為怪異或是身心有缺陷的人了，往往都給予不友善的態度甚至會霸凌他們。大家普遍認為他們是怪人，給與異樣眼光，對於這些人來說，這個世界有的甚至父母，都不會友善的對待自己。片中許明哲以及 193（意識載體）分別用不同的方法，去對待這些人。但許明哲這種極端的行為，也許演出很多人內心不敢表現出的想法，而 193 則是父母對待自己子女愛的體現。不禁讓人反思，是不是因為我們而造就了這個不友善的世界？\n被『正義』包裝的『惡』 片尾王警官說：『我們沒辦法知道怪物的腦中想什麼，或許殺了他們，反而對他們比較好。』這句話就跟許明哲對沈宜玲（張榕容）講的話一樣：『這世界對他們並不友善，所以殺了他們。對他們比較好。』。往往有些『惡意』的外層包裝了『正義』，社會大眾就會覺的是合理的事，但是否只要是『正義』就是絕對的正確呢？\n不管這個世界怎麼看你，你都要相信你自己。 193 對女兒說：『不管這個世界怎麼看你，你都要相信你自己。』\n現在的人大多數在意『別人怎麼看我』，但我們是想要活出『我夢想中的自己』，還是『別人眼中的自己』。適度的在意並把意見化為養分是必要的，但應該要過濾，不是照單全收。\n最後，你們有沒有看我阿嬤啊","tags":["電影心得"],"title":"複身犯 - 寫出你的名字，你是誰？","type":"電影心得","url":"movie/plurality","weight":0,"wordcount":24},{"authors":null,"categories":null,"date":1615680000,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1615680000,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/%E9%9B%BB%E5%BD%B1%E5%BF%83%E5%BE%97/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/%E9%9B%BB%E5%BD%B1%E5%BF%83%E5%BE%97/","section":"tags","summary":"","tags":null,"title":"電影心得","type":"tags","url":"/ianlife/tags/%E9%9B%BB%E5%BD%B1%E5%BF%83%E5%BE%97/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1615593600,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1615593600,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/algolia/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/algolia/","section":"tags","summary":"","tags":null,"title":"Algolia","type":"tags","url":"/ianlife/tags/algolia/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1615593600,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1615593600,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/blog/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/blog/","section":"tags","summary":"","tags":null,"title":"blog","type":"tags","url":"/ianlife/tags/blog/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1615593600,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1615593600,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/hugo/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/hugo/","section":"tags","summary":"","tags":null,"title":"hugo","type":"tags","url":"/ianlife/tags/hugo/","weight":0,"wordcount":0},{"authors":null,"categories":["TECH"],"date":1615593600,"description":"Algolia 是為你在APP或網站提供搜索功能的最佳方式之一，在 Hugo 中加入 Algolia，讓你更方便尋找以前的文章。","dir":"blog/technology/build_blog/","expirydate":-62135596800,"fuzzywordcount":800,"keywords":null,"kind":"page","lang":"zh","lastmod":1615593600,"objectID":"487bf2884c87079d0a7c7184147429f6","permalink":"https://ianjustin39.github.io/ianlife/build-blog/hugo-and-algolia/","publishdate":"2021-03-13T00:00:00Z","readingtime":4,"relpermalink":"/ianlife/build-blog/hugo-and-algolia/","section":"blog","summary":"隨著文章越來越多，要找到以前寫的文章就越來越麻煩，所以就一直想尋找站內搜索的功能使用。之前有試用 google 的站內搜索功能，但總覺得整體不是很好看，也就沒有繼續使用。直到最近看到 Algolia ，可建立文章的索引，將資料上傳到 Algolia，再藉由串接 API 就可以完成搜索功能。\n接下來就開始建立站內搜索功能吧。\n註冊 Algolia  第一步就是要到 Algolia 註冊帳號，登入後會要求輸入一個 index（等等要用到這個 index），然後會以這個 index 建立一個 app ，接著選擇存取的國家（我是選日本），完成之後會有這個畫面。\n然後點選左邊的 API Keys，這邊有等等設定需要使用的參數，可以先將他們記下來。\n註：Algolia 有分幾個付費等級，現在有 15 天試用期，不過因為 blog 只需要簡單的搜索文章的功能，這裡目前是使用免費版，若要更進階的功能可以自行研究看看。\nhugo 生成索引文件  1. 修改 config.toml 修改./config.toml設定好需要的參數。\n[outputs] home = [\u0026#34;HTML\u0026#34;, \u0026#34;RSS\u0026#34;, \u0026#34;Algolia\u0026#34;] [outputFormats.Algolia] baseName = \u0026#34;algolia\u0026#34; isPlainText = true mediaType = \u0026#34;application/json\u0026#34; notAlternative = true [params.algolia] appId = \u0026#34;剛剛看到的 ID\u0026#34; indexName = \u0026#34;一開始輸入的 index\u0026#34; searchOnlyKey = \u0026#34;剛剛看到的 Search Only Key\u0026#34; vars = [\u0026#34;title\u0026#34;, \u0026#34;summary\u0026#34;, \u0026#34;date\u0026#34;, \u0026#34;publishdate\u0026#34;, \u0026#34;expirydate\u0026#34;, \u0026#34;permalink\u0026#34;] params = [\u0026#34;categories\u0026#34;, \u0026#34;tags\u0026#34;, \u0026#34;series\u0026#34;]","tags":["Blog","Hugo","Algolia"],"title":"在 Hugo Blog 中加上 Algolia 文章搜索工具","type":"Build My Blog","url":"/build-blog/hugo-and-algolia","weight":0,"wordcount":729},{"authors":null,"categories":null,"date":1615593600,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1615593600,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/series/%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84-blog/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/series/%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84-blog/","section":"series","summary":"","tags":null,"title":"建立自己的 Blog","type":"series","url":"/ianlife/series/%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84-blog/","weight":0,"wordcount":0},{"authors":null,"categories":["LIFE"],"date":1615507200,"description":"寧靜的下午坐在咖啡廳、喝著咖啡、看著書，思考這『這杯咖啡的價值』是什麼。","dir":"blog/life/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":["咖啡","時間","coffee","time"],"kind":"page","lang":"zh","lastmod":1615507200,"objectID":"99c371cfb85415aee26baaaaa3512570","permalink":"https://ianjustin39.github.io/ianlife/life/a-cup-of-coffee/","publishdate":"2021-03-12T00:00:00Z","readingtime":1,"relpermalink":"/ianlife/life/a-cup-of-coffee/","section":"blog","summary":"到咖啡廳唸書？  很多人喜歡到咖啡廳看書，曾經的我覺得，為何要花錢去咖啡廳看書？自制力高一點在家看不就好了，何必要多花一筆錢？那到底有沒有必要去咖啡廳唸書？\n一杯咖啡的價值  每到週末，我就會想著：『難得的假日，休息一下再來做事好了！』，然後就晚上了。是自制力不足，還是目標不夠明確所以才導致這個結果呢？\n原子習慣一書中提到，『改變習慣的四大法則之一：讓習慣淺而易見』，反之則是讓壞習慣視而不見。那這跟在家看書有什麼關係？\n想想自己房間裡的環境，看到床就想睡一下、看到電動就想玩一下、走到客廳看到電視就想看一會兒\u0026hellip;諸如此類，當我們想要在這充滿誘惑的環境做一些不屬於這個環境的事情，想必會有一定的難度，而我們的時間往往就這樣被消磨掉了。一個週末、兩個週末\u0026hellip;這樣的時間累計起來，其實也是滿可觀的。\n而我開始對『一杯咖啡的價值』開始有了不一樣的想法。他是單純菜單上的 60/100 元的『飲料』，還是他可以想成，你用這樣的價錢，控制了你一天的『時間』？\n資產與負債  一杯咖啡，怎麼會講到資產與負債？我認為這兩件事的觀念有點相似。現在常聽到人問，『什麼是資產？你的房子是不是？你的車子是不是？』，而答案通常會是『房子那來出租，就會是資產；車子拿來載客人，也是資產。』\n那我買一杯咖啡，到底是投資還是消費？\n一杯咖啡換一天的時間  高爾基：『時間是最公平合理的，它從不多給誰一分。』  老天給我們最公平的東西就是——時間，每個人都有，無論是貧賤、富貴，每個人都是一樣的，而時間是公平的，我們每個人能擁有它，但因為使用它的方式不同，導致在『相同』的時間內，沒有相同的結果。\n而現在，我用一杯咖啡，換到一個沒有誘惑的環境、換來一天的時間，這件事讓我不再認為『到咖啡廳唸書』是個浪費錢的事情，反而覺得是非常值得的『投資』。","tags":["隨手寫"],"title":"咖啡的價值 - 是買咖啡還是買時間？","type":"隨手寫","url":"life/a-cup-of-coffee","weight":0,"wordcount":16},{"authors":null,"categories":null,"date":1615507200,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1615507200,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/series/%E9%9A%A8%E6%89%8B%E5%AF%AB/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/series/%E9%9A%A8%E6%89%8B%E5%AF%AB/","section":"series","summary":"","tags":null,"title":"隨手寫","type":"series","url":"/ianlife/series/%E9%9A%A8%E6%89%8B%E5%AF%AB/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1615507200,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1615507200,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/%E9%9A%A8%E6%89%8B%E5%AF%AB/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/%E9%9A%A8%E6%89%8B%E5%AF%AB/","section":"tags","summary":"","tags":null,"title":"隨手寫","type":"tags","url":"/ianlife/tags/%E9%9A%A8%E6%89%8B%E5%AF%AB/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1615248000,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1615248000,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/data-structures/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/data-structures/","section":"tags","summary":"","tags":null,"title":"Data Structures","type":"tags","url":"/ianlife/tags/data-structures/","weight":0,"wordcount":0},{"authors":null,"categories":["TECH"],"date":1615248000,"description":"在電腦科學中，trie，又稱字首樹或字典樹，是一種有序樹，用於儲存關聯陣列，其中的鍵通常是字串。","dir":"blog/technology/data_structures_and_algorithms/","expirydate":-62135596800,"fuzzywordcount":400,"keywords":["演算法","資料結構","Data Structures","Algorithm","Trie","字首樹","字典樹"],"kind":"page","lang":"zh","lastmod":1615248000,"objectID":"966c45bb0d352be34385b13bbe054e39","permalink":"https://ianjustin39.github.io/ianlife/algorithms/tries/","publishdate":"2021-03-09T00:00:00Z","readingtime":2,"relpermalink":"/ianlife/algorithms/tries/","section":"blog","summary":"","tags":["Algorithm","Data Structures"],"title":"字典樹 - Trie","type":"Data Structures and Algorithms","url":"algorithms/tries","weight":0,"wordcount":355},{"authors":null,"categories":["TECH"],"date":1615075200,"description":"","dir":"blog/technology/data_structures_and_algorithms/","expirydate":-62135596800,"fuzzywordcount":400,"keywords":["演算法","Algorithm","Binary search","資料結構","Data Structures","二分搜尋"],"kind":"page","lang":"zh","lastmod":1615075200,"objectID":"8f9a5ac419e7d8d884844dffeaddfcbf","permalink":"https://ianjustin39.github.io/ianlife/algorithms/binary-search/","publishdate":"2021-03-07T00:00:00Z","readingtime":2,"relpermalink":"/ianlife/algorithms/binary-search/","section":"blog","summary":"\u003cp\u003e\u003ca href=\"https://www.geeksforgeeks.org/binary-search/\" target=\"_blank\"\u003e圖片來源\u003c/a\u003e\n\u003cbr\u003e\u003c/p\u003e","tags":["Algorithm","Data Structures"],"title":"二分搜尋演算法 (Binary search algorithm) - 終極密碼","type":"Data Structures and Algorithms","url":"algorithms/binary-search","weight":0,"wordcount":336},{"authors":null,"categories":["Learning"],"date":1613865600,"description":"40歲是『夾心世代』。為了過得更好，留下對自己真正必要的東西。","dir":"blog/learning/reading/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":["為了遇見40歲更好的自己","讀書心得"],"kind":"page","lang":"zh","lastmod":1613865600,"objectID":"f59d99e846f350111dfdfafb56b1e65e","permalink":"https://ianjustin39.github.io/ianlife/read/40-years-old/","publishdate":"2021-02-21T00:00:00Z","readingtime":1,"relpermalink":"/ianlife/read/40-years-old/","section":"blog","summary":"讀後心得 40歲是夾在上一代及下一代中間的一個世代，為了讓自己過得更好，需要學會捨棄一些事物。但往往要捨棄時，又會有些捨不得。就像要整理自己的衣櫃時，拿出很多衣服可能一年內根本沒拿出來穿過，但卻捨不得丟掉，又把他放回衣櫃裡佔去了衣櫃的空間。而哪些東西是該捨棄，而為什麼要捨棄，捨棄之後可以達到什麼效果，這本書基本上都有提到。書中有5個大章節、43個小章節，我挑幾個感受比較深的項目拿來舉例。\n1. 『勇於捨棄』，提升人生的品質 我還年輕，我全身都很健康；這個我以前就是這樣做，絕對沒問題。這些『自信』、『堅持』大家一定都有過。但隨著時間的推移，我們會變老，時代會進步。需要不段的定期檢討、不段的求新求變，才不會被社會淘汰。華特·迪士尼說過：『迪士尼永遠不會完工，維持現狀等於是一種退步。』\n2. 習慣改變，行動自然改變 一開始有提到整理衣櫃。根據調查顯示，女性的衣櫃內有70%的衣服是沒再穿的，只有30%的衣服是平常有再穿的。作者建議把這70%的衣服丟掉，留下真正需要的30%。而依照人的習慣，還是會把這70%補滿。但補滿以後的衣櫃，裡面都是會穿出去的衣服。套用到人身上也一樣，應該適時的檢視並捨棄自己不需要的東西，補充新事物給自己。\n3. 透過『選擇與集中』，提升工作的成果 在樹立目標的時候，我們往往會想要達成多件事情。例如：每個月要讀完一本書、英文要考到多益900分、要養成每天運動的習慣、要學習股票投資\u0026hellip;等等。但之後會發現每件事都有做，但都沒有達到目標。研究顯示，人類大腦無法同時判斷多組情報，因此三種左右是最適當的數量。所以我們可以把要執行的事情縮至三項，將其他事項暫時捨去，才可以專心的去完成每件事。此外，也要定期的檢視自己的執行項目是否有需要或是可更新成更好的方法，並定期的記錄下來。\n4. 調整『時間分配』，改變成長速度 『我今天要看完一個線上課程，但上完班好累喔，休息一下再看好了！』，相信大家都有這個經驗，但休息一下之後，就準備洗澡睡覺了。如何避免這種情況發生呢？書裡建議我們，事先『算好』時間。也就是將你要做的是用時間去切分好，如下圖：\n應先固定好時間，再決定做什麼事。但通常我們無法『完美的』執行我們的計劃，有時可能會有突發狀況發生，所以也必須捨棄『行程必須百分之百完成』的義務感，並不是沒做到就是失敗，而是要有些彈性。\n5. 和『真正重要的人』建立人際關係 到新公司就減少與前公司聚餐的次數，因為『如果不跟現在公司的同事打好關係，就無法創造成果。』。\n並不是到了新公司就要捨棄舊同事，而是現在是與新同事共事，要與他們一起創造成果。但如何與同事來往更加緊密？書中提到『讓溝通戲劇性改變之三種應可棄的東西』\n 為了得到旁人的信賴，請停止『責人』：在遇到問題時，應該先思考自己可以付出什麼，而非先找戰犯。 若想討人喜歡，請捨棄『想討人喜歡的念頭』：應該適時的表達意見，而不是一直考慮是否會被對方討厭。 想要聽見對方的真心話，請捨棄『先入為主的觀念』：產品好不好用，是客戶決定。我們應該思考『這件事由誰判定？』而非自己先覺得對方怎想。   『改變行為一定可以改變結果』，書中讓我們思考什麼該東西是現在應該捨去的。例如：過度的自信、自我堅持、達到目標途中不需要的東西\u0026hellip;等等。專心對待眼前最重要的事物，才有辦法完成目標。這本書雖然有些觀點個人是稍微不認同，不過整體來說是不錯的，可以看看！！\n閱讀筆記 若想參考閱讀筆記，可以點 這裡 參考","tags":["讀書心得"],"title":"為了遇見40歲更好的自己","type":"讀書心得","url":"/read/40-years-old","weight":0,"wordcount":27},{"authors":null,"categories":["Learning"],"date":1611360000,"description":"在華氏 25 度的房間內有著一塊冰塊，隨著房間溫度緩慢的增加，26、27、28 。冰塊依然在，29、30、31 直到 32 （攝氏零度）度時，冰塊開始融化。如同習慣一樣，一開始可能沒有太大的差異，但從某一刻開始就會起到巨大的變化。","dir":"blog/learning/reading/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":["原子習慣","讀書心得","atom habits"],"kind":"page","lang":"zh","lastmod":1611360000,"objectID":"728c7b9b2b8626a049a66710b176ddea","permalink":"https://ianjustin39.github.io/ianlife/read/atom-habits/","publishdate":"2021-01-23T00:00:00Z","readingtime":1,"relpermalink":"/ianlife/read/atom-habits/","section":"blog","summary":"讀後心得 如果每天進步百分之一，持續一年你會進步37倍； 每天退步百分之一，一年後就會弱化到趨近於零，時間會放大成功與失敗之間的差距。 當我們想著要改變的時候，往往想著馬上就可以看到成果，但都忽略一些細微的改變。想想每年年初都訂立一些目標，我 TOEIC 要考 950 以上、我今年要變成巨巨\u0026hellip;等等。但到了年底發現，我今年跟去年好像一樣都沒變，怎麼會這樣？\n決定成功與失敗的，並非目標，而是系統。\n例如：Ａ跟Ｂ都想要有六塊腹肌，但一年後，Ａ成功的練出了腹肌，Ｂ卻跟原本的一樣。差異在哪？\nＡ一周至少上六天健身房，且有做飲食控管並記錄每天的身體數值、飲食及訓練項目。Ｂ一週也上六天健身房，但卻沒有控制飲食以及紀錄。兩個人的目標相同，但執行方式（系統）卻不一樣，所以造就了不同的結果。\n可以發現，雖然定了目標，但系統執行的方向不對，所呈現的結果也不一樣。\n我們往往把注意力過於放在目標上，忽略了如何執行這件事。而對於想要改變習慣，卻因為習慣過於難執行，又或是生活讓我們只能安於現狀，最後只能回歸原樣。\n提示 \u0026lt;\u0026gt; 讓提示顯而易見 渴望 \u0026lt;\u0026gt; 讓習慣有吸引力 回應 \u0026lt;\u0026gt; 讓行動輕而易舉 獎賞 \u0026lt;\u0026gt; 讓獎賞令人滿足 這是書中提到養成習慣的四種方法，簡單用這四個法則來延續六塊肌例子：\n  讓提示顯而易見\n為了養成健身的習慣，將健身手套放在書桌上，看到手套就知道該去健身房了。\n  讓習慣有吸引力\n去健身房只是為了健身？No！當然是為了看健身妹子跟巨巨的肌肉拉，所以會為了這件事所以去健身房。\n  讓行動輕而易舉\n選一間離家走路三分鐘的健身房，這樣就算下雨也只需要撐個傘就可以到了。\n  讓獎賞令人滿足\n每天持續記錄自己的體態，看到改變而帶來的成就感。（或是因為去健身房脫單）\n  而壞習慣就反向而行，這樣就可以比較有效的建立自己的習慣。\n看完這本書後，練習了一下覺得其實滿受用的。書中也有舉許多實例，讓法則比較淺顯易懂。滿值得入手的一本好書，不愧是暢銷前幾名。\n閱讀筆記 因為是心得所以不想打太多筆記類的東西，若想看閱讀筆記，可以點 這裡 參考","tags":["讀書心得","好書推薦"],"title":"原子習慣 - 細微改變帶來巨大成就","type":"讀書心得","url":"/read/atom-habits","weight":0,"wordcount":40},{"authors":null,"categories":null,"date":1605571200,"description":"","dir":"photograph/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"page","lang":"zh","lastmod":1605571200,"objectID":"fc42ee396fdfdf07c1c83e1212873557","permalink":"https://ianjustin39.github.io/ianlife/photograph/20201117-jiaminglake/","publishdate":"2020-11-17T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/photograph/20201117-jiaminglake/","section":"photograph","summary":"","tags":null,"title":"嘉明湖","type":"photograph","url":"/ianlife/photograph/20201117-jiaminglake/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1601942400,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1601942400,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/behavioural-pattern/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/behavioural-pattern/","section":"tags","summary":"","tags":null,"title":"Behavioural Pattern","type":"tags","url":"/ianlife/tags/behavioural-pattern/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1601942400,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1601942400,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/design-pattern/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/design-pattern/","section":"tags","summary":"","tags":null,"title":"Design Pattern","type":"tags","url":"/ianlife/tags/design-pattern/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1601942400,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1601942400,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/series/%E5%BE%9E%E7%94%9F%E6%B4%BB%E4%B8%AD%E8%AA%8D%E8%AD%98-design-pattern/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/series/%E5%BE%9E%E7%94%9F%E6%B4%BB%E4%B8%AD%E8%AA%8D%E8%AD%98-design-pattern/","section":"series","summary":"","tags":null,"title":"從生活中認識 Design Pattern","type":"series","url":"/ianlife/series/%E5%BE%9E%E7%94%9F%E6%B4%BB%E4%B8%AD%E8%AA%8D%E8%AD%98-design-pattern/","weight":0,"wordcount":0},{"authors":null,"categories":["TECH"],"date":1601942400,"description":"定義一系列演算法，並將其封裝起來，使他們可以相互替換，演算法的變換不影響使用。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":600,"keywords":["Design Pattern","Behavioural Pattern","Strategy Pattern","策略模式"],"kind":"page","lang":"zh","lastmod":1601942400,"objectID":"0f7866f4b9b889b58c79dfd956dbe5c1","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/strategy-pattern/","publishdate":"2020-10-06T00:00:00Z","readingtime":3,"relpermalink":"/ianlife/design-pattern/strategy-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    定義一系列演算法，並將其封裝起來，使他們可以相互替換，演算法的變換不影響使用。","tags":["Design Pattern","Behavioural Pattern"],"title":"策略模式 | Strategy Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/strategy-pattern","weight":0,"wordcount":505},{"authors":null,"categories":["TECH"],"date":1601856000,"description":"多個物件之間存在著一對多的依賴關係，當一個物件發生改變時，所有跟他有關的物件都會被通知且更新。例如：訂閱youtuber，發布新影片就會接收到通知即觀察者模式。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":["Design Pattern","Behavioural Pattern","Observer Pattern","觀察者模式"],"kind":"page","lang":"zh","lastmod":1601856000,"objectID":"0fd220d9ec5662798c06ffdf874c9402","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/observer-pattern/","publishdate":"2020-10-05T00:00:00Z","readingtime":3,"relpermalink":"/ianlife/design-pattern/observer-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    多個物件之間存在著一對多的依賴關係，當一個物件發生改變時，所有跟他有關的物件都會被通知且更新。","tags":["Design Pattern","Behavioural Pattern"],"title":"觀察者模式 | Observer Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/observer-pattern","weight":0,"wordcount":455},{"authors":null,"categories":["TECH"],"date":1601769600,"description":"備忘錄模式在不破壞封裝的前提下，儲存一個物件的某個狀態，以便於需要的時候將物件恢復到原先儲存的狀態。例如：後悔藥。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":["Design Pattern","Behavioural Pattern","Memento Pattern","備忘錄模式"],"kind":"page","lang":"zh","lastmod":1601769600,"objectID":"835bfcba3865a6c2408d08001c1fc8ff","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/memento-pattern/","publishdate":"2020-10-04T00:00:00Z","readingtime":3,"relpermalink":"/ianlife/design-pattern/memento-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    在不破壞封裝的前提下，儲存一個物件的某個狀態，以便於需要的時候將物件恢復到原先儲存的狀態。","tags":["Design Pattern","Behavioural Pattern"],"title":"備忘錄模式 | Memento Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/memento-pattern","weight":0,"wordcount":436},{"authors":null,"categories":["TECH"],"date":1601683200,"description":"有狀態的物件，把複雜的邏輯判斷分配到不同的狀態物件中，允許狀態物件在其內部狀態發生改變時改變行為。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":["Design Pattern","Behavioural Pattern","State Pattern","狀態模式"],"kind":"page","lang":"zh","lastmod":1601683200,"objectID":"42f59d1ae5de1185a240bbd3614e6e3f","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/state-pattern/","publishdate":"2020-10-03T00:00:00Z","readingtime":3,"relpermalink":"/ianlife/design-pattern/state-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    有狀態的物件，把複雜的邏輯判斷分配到不同的狀態物件中，允許狀態物件在其內部狀態發生改變時改變行為。","tags":["Design Pattern","Behavioural Pattern"],"title":"狀態模式 | State Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/state-pattern","weight":0,"wordcount":490},{"authors":null,"categories":["TECH"],"date":1601596800,"description":"定義一個 Mediator 物件用來封裝一組物件的互動方式。Mediator 藉由避免物件間相互直接的引用，從而降低它們之間的耦合程度，並且可以讓我們獨立地改變這些物件間的互動方式。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":800,"keywords":["Design Pattern","Behavioural Pattern","Mediator Pattern","中介者模式"],"kind":"page","lang":"zh","lastmod":1601596800,"objectID":"b930d4a1aee037cd1fca0862a45364a7","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/mediator-pattern/","publishdate":"2020-10-02T00:00:00Z","readingtime":4,"relpermalink":"/ianlife/design-pattern/mediator-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    定義一個 Mediator 物件用來封裝一組物件的互動方式。Mediator 藉由避免物件間相互直接的引用，從而降低它們之間的耦合程度，並且可以讓我們獨立地改變這些物件間的互動方式。","tags":["Design Pattern","Behavioural Pattern"],"title":"中介者模式 | Mediator Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/mediator-pattern","weight":0,"wordcount":797},{"authors":null,"categories":["TECH"],"date":1601510400,"description":"迭代氣模式提供一種方法可以順序性讀取一個集合物件中的各個元素，而又不會暴露該物件的內部表示。如 Java 中的 Collection、List、Set、Map 等都包含了迭代器。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":600,"keywords":["Design Pattern","Behavioural Pattern","Iterator Pattern","迭代器模式"],"kind":"page","lang":"zh","lastmod":1601510400,"objectID":"72e9c85a46a3874975291320408e073b","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/iterator-pattern/","publishdate":"2020-10-01T00:00:00Z","readingtime":3,"relpermalink":"/ianlife/design-pattern/iterator-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    提供一種方法可以順序性讀取一個集合物件中的各個元素，而又不會暴露該物件的內部表示。","tags":["Design Pattern","Behavioural Pattern"],"title":"迭代器模式 | Iterator Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/iterator-pattern","weight":0,"wordcount":556},{"authors":null,"categories":["TECH"],"date":1601424000,"description":"命令模式將一個請求封裝成一個物件，讓你可用不同的請求對客戶進行參數化、對請求排隊或記錄請求日誌，以及支援可取消的操作。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":700,"keywords":["Design Pattern","Behavioural Pattern","Command Pattern","命令模式"],"kind":"page","lang":"zh","lastmod":1601424000,"objectID":"a0561040390f99c62d35649b4b38efc9","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/command-pattern/","publishdate":"2020-09-30T00:00:00Z","readingtime":4,"relpermalink":"/ianlife/design-pattern/command-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義   The Command Pattern encapsulates a request as an object, thereby letting you parameterize other objects with different requests, queue or log requests, and support undoable operations.","tags":["Design Pattern","Behavioural Pattern"],"title":"命令模式 | Command Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/command-pattern","weight":0,"wordcount":685},{"authors":null,"categories":["TECH"],"date":1601337600,"description":"責任鏈模式就是將多個物件連成一條鏈，沿著這條鏈傳遞至每一個物件並處理請求，當這個物件沒有處理的權限時，能夠將這個請求，傳遞給下一個物件繼續處理。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":600,"keywords":["Design Pattern","Behavioural Pattern","Chain of Responsibility Pattern","責任鏈模式"],"kind":"page","lang":"zh","lastmod":1601337600,"objectID":"0aeb6eb2855104f9855f139a4b397eca","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/chain-of-responsibility/","publishdate":"2020-09-29T00:00:00Z","readingtime":3,"relpermalink":"/ianlife/design-pattern/chain-of-responsibility/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    將多個物件連成一條鏈，沿著這條鏈傳遞至每一個物件並處理請求。","tags":["Design Pattern","Behavioural Pattern"],"title":"責任鏈模式 | Chain of Responsibility Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/chain-of-responsibility","weight":0,"wordcount":556},{"authors":null,"categories":null,"date":1601251200,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1601251200,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/structural-pattern/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/structural-pattern/","section":"tags","summary":"","tags":null,"title":"Structural Pattern","type":"tags","url":"/ianlife/tags/structural-pattern/","weight":0,"wordcount":0},{"authors":null,"categories":["TECH"],"date":1601251200,"description":"代理模式目的爲其他物件提供一種代理以控制對這個物件的訪問。應用可以為遠端代理、虛擬代理、保護代理、智慧代理等等。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":["Design Pattern","Structural Pattern","Proxy Pattern","代理模式"],"kind":"page","lang":"zh","lastmod":1601251200,"objectID":"8b7975c4f22e370b75f9d68166d2f53b","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/proxy-pattern/","publishdate":"2020-09-28T00:00:00Z","readingtime":2,"relpermalink":"/ianlife/design-pattern/proxy-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    爲其他物件提供一種代理以控制對這個物件的訪問。","tags":["Design Pattern","Structural Pattern"],"title":"代理模式 | Proxy Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/proxy-pattern","weight":0,"wordcount":405},{"authors":null,"categories":["TECH"],"date":1601164800,"description":"享元模式是運用共享技術有效地支持大量細粒度的物件。他可以避免大量相似類的開銷，在軟體開發中如果需要生成大量細粒度的類別實體來表示數據，如果這些實體除了幾個參數外基本上都是相同的，這時候就可以使用享元模式來大幅度減少需要實體化類的數量。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":800,"keywords":["Design Pattern","Structural Pattern","Flyweight Pattern","享元模式"],"kind":"page","lang":"zh","lastmod":1601164800,"objectID":"960b3df457548f124187f9ce86986a4b","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/flyweight-pattern/","publishdate":"2020-09-27T00:00:00Z","readingtime":4,"relpermalink":"/ianlife/design-pattern/flyweight-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    運用共享技術有效地支持大量細粒度的物件。","tags":["Design Pattern","Structural Pattern"],"title":"享元模式 | Flyweight Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/flyweight-pattern","weight":0,"wordcount":739},{"authors":null,"categories":["TECH"],"date":1601078400,"description":"外觀模式為子系統中的一組接口提供一個統一的高層接口，使得子系統更容易使用。比方說，當要找銀行貸款時，我們只需要找專員，而專員把我們的資料拿到後，要回銀行各部門跑流程，最後才能核貸給我們。行員就是接口，銀行各部門就是子系統。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":["Design Pattern","Structural Pattern","Facade Pattern","外觀模式"],"kind":"page","lang":"zh","lastmod":1601078400,"objectID":"55e3a55aa00c3d6e5578a57e9814f9ce","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/facede-pattern/","publishdate":"2020-09-26T00:00:00Z","readingtime":3,"relpermalink":"/ianlife/design-pattern/facede-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    為子系統中的一組接口提供一個統一的高層接口，使得子系統更容易使用。","tags":["Design Pattern","Structural Pattern"],"title":"外觀模式 | Facade Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/facede-pattern","weight":0,"wordcount":479},{"authors":null,"categories":["TECH"],"date":1600992000,"description":"裝飾者模式可以想成買了一間房子不需要因為要裝潢，而改變整體結構。只需要在既有的結構上，加上要裝潢的材料即可。即動態將責任附加在物件上，若要擴展功能上，裝飾者提供比繼承更有彈性的替代方案。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":["Design Pattern","Structural Pattern","Decorator Pattern","裝飾者模式"],"kind":"page","lang":"zh","lastmod":1600992000,"objectID":"a77c9a7d38e7cb020faa4850403350c7","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/decorator-pattern/","publishdate":"2020-09-25T00:00:00Z","readingtime":3,"relpermalink":"/ianlife/design-pattern/decorator-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    裝飾模式動態將責任附加在物件上，若要擴展功能上，裝飾者提供比繼承更有彈性的替代方案。","tags":["Design Pattern","Structural Pattern"],"title":"裝飾者模式 | Decorator Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/decorator-pattern","weight":0,"wordcount":493},{"authors":null,"categories":["TECH"],"date":1600905600,"description":"組合模式就是將元件做分離，依照需求一一組裝起來，建立不同需求的物件。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":900,"keywords":["Design Pattern","Structural Pattern","Composite Pattern","组合模式"],"kind":"page","lang":"zh","lastmod":1600905600,"objectID":"f33943d35f4381a387979b1c3abc43fa","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/composite-pattern/","publishdate":"2020-09-24T00:00:00Z","readingtime":5,"relpermalink":"/ianlife/design-pattern/composite-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    物件以樹狀結構組合，做為表現出整體-部分的階層關係。","tags":["Design Pattern","Structural Pattern","鐵人賽"],"title":"组合模式 | Composite Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/composite-pattern","weight":0,"wordcount":865},{"authors":null,"categories":null,"date":1600905600,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1600905600,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/","section":"tags","summary":"","tags":null,"title":"鐵人賽","type":"tags","url":"/ianlife/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/","weight":0,"wordcount":0},{"authors":null,"categories":["TECH"],"date":1600819200,"description":"橋接模式是將抽象部分與實現部分分離，使它們都可以獨立的變化。即用合成關係代替繼承關係。如同合成/聚合複用原則。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":400,"keywords":["Design Pattern","Structural Pattern","Bridge Pattern","橋接模式"],"kind":"page","lang":"zh","lastmod":1600819200,"objectID":"23f04ea8783d2b5d61cdb127df184aae","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/bridge-pattern/","publishdate":"2020-09-23T00:00:00Z","readingtime":2,"relpermalink":"/ianlife/design-pattern/bridge-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    將抽象部分與實現部分分離，使它們都可以獨立的變化。","tags":["Design Pattern","Structural Pattern","鐵人賽"],"title":"橋接模式 | Bridge Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/bridge-pattern","weight":0,"wordcount":399},{"authors":null,"categories":["TECH"],"date":1600732800,"description":"適配器模式如同出國玩時，一定會有使用電器的需求。但每個國家的插座及電壓都不一樣，這時就會拿出事先準備好的轉接頭，藉由轉接頭將插座與電器插頭做連接。適配器模式的目的在於將一個類別的介面轉換成客戶希望的另外一個介面，Adapter使得原本由於介面相容而不能一起工作的那些類別可以一起工作。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":700,"keywords":["Design Pattern","Structural Pattern","Adapter Pattern","適配器模式","接配器模式"],"kind":"page","lang":"zh","lastmod":1600732800,"objectID":"5e8185d6a99d2fdcc754293da146869d","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/adapter-pattern/","publishdate":"2020-09-22T00:00:00Z","readingtime":3,"relpermalink":"/ianlife/design-pattern/adapter-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    The Adapter Pattern converts the interface of a class into another interface the clients expect.","tags":["Design Pattern","Structural Pattern","鐵人賽"],"title":"適配器模式 | Adapter Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/adapter-pattern","weight":0,"wordcount":628},{"authors":null,"categories":null,"date":1600646400,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1600646400,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/creational-pattern/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/creational-pattern/","section":"tags","summary":"","tags":null,"title":"Creational Pattern","type":"tags","url":"/ianlife/tags/creational-pattern/","weight":0,"wordcount":0},{"authors":null,"categories":["TECH"],"date":1600646400,"description":"建立原型物件，透過複製的方式建立大量物件，而非傳統的建立方式。這為原型模式主張的目標，不但能提升效能，也隱藏了創建新物件的復雜性。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":900,"keywords":["Design Pattern","Creational Pattern","Prototype Pattern","原型模式"],"kind":"page","lang":"zh","lastmod":1600646400,"objectID":"2424a9255953331f9049e13467b007d2","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/prototype-pattern/","publishdate":"2020-09-21T00:00:00Z","readingtime":4,"relpermalink":"/ianlife/design-pattern/prototype-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    用原型例項指定建立物件的種類，並且通過拷貝這些原型建立新的物件。","tags":["Design Pattern","Creational Pattern","鐵人賽"],"title":"原型模式 | Prototype Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/prototype-pattern","weight":0,"wordcount":807},{"authors":null,"categories":["TECH"],"date":1600560000,"description":"生成器模式就是將元件做分離，依照需求一一組裝起來，建立不同需求的物件。如同不同的人組一台電腦需要各種不同的零件一樣。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":900,"keywords":["Design Pattern","Creational Pattern","Builder Pattern","生成器模式"],"kind":"page","lang":"zh","lastmod":1600560000,"objectID":"4ac5f31498e8ce0fef67005fa7eea270","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/builder-pattern/","publishdate":"2020-09-20T00:00:00Z","readingtime":5,"relpermalink":"/ianlife/design-pattern/builder-pattern/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    把一個複雜物件的建構與樣貌分離，如此相同的建構過程可以產生不同樣貌的物件","tags":["Design Pattern","Creational Pattern","鐵人賽"],"title":"生成器模式 | Builder Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/builder-pattern","weight":0,"wordcount":865},{"authors":null,"categories":["TECH"],"date":1600473600,"description":"抽象工廠主要是由繼承來的次類別來決定要產生哪種實體產品，其主要目的是將客戶從實體型態中鬆綁。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":700,"keywords":["Design Pattern","Creational Pattern","Abstract Factory Method","抽象工廠模式"],"kind":"page","lang":"zh","lastmod":1600473600,"objectID":"4a4ee77777cd4b7f4ff205cbb807e504","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/abstract-factory-pattern/","publishdate":"2020-09-19T00:00:00Z","readingtime":4,"relpermalink":"/ianlife/design-pattern/abstract-factory-pattern/","section":"blog","summary":"","tags":["Design Pattern","Creational Pattern","鐵人賽"],"title":"抽象工廠模式 | Abstract Factory Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/abstract-factory-pattern","weight":0,"wordcount":646},{"authors":null,"categories":["TECH"],"date":1600387200,"description":"簡單工廠模式：藉由定義一個class來負責建立其他class的instance，被建立的instance通常都具有共同的super class；工廠方法模式：定義了一個建立物件的insterface，由子類別決定實體化的類別為何者。而兩者之間的差異在...","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":1000,"keywords":["Design Pattern","Creational Pattern","Factory Method","Sample Factory","工廠模式","工廠方法模式","簡單工廠模式"],"kind":"page","lang":"zh","lastmod":1600387200,"objectID":"7a09007a457514f569ec993efb1abe3c","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/factory-pattern/","publishdate":"2020-09-18T00:00:00Z","readingtime":5,"relpermalink":"/ianlife/design-pattern/factory-pattern/","section":"blog","summary":"","tags":["Design Pattern","Creational Pattern","鐵人賽"],"title":"工廠模式 | Factory Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/factory-pattern","weight":0,"wordcount":935},{"authors":null,"categories":["TECH"],"date":1600300800,"description":"Singleton = one instance ONLY。單例模式希望執行一個且唯一一個Singleton物件且Singleton物件可以全局使用。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":1000,"keywords":["Design Pattern","Creational Pattern","Singleton Pattern","單例模式"],"kind":"page","lang":"zh","lastmod":1600300800,"objectID":"850f31bee8cfb4ef508a6e487ae2d916","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/singleton-pattern/","publishdate":"2020-09-17T00:00:00Z","readingtime":5,"relpermalink":"/ianlife/design-pattern/singleton-pattern/","section":"blog","summary":"","tags":["Design Pattern","Creational Pattern","鐵人賽"],"title":"單例模式 | Singleton Pattern","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/singleton-pattern","weight":0,"wordcount":934},{"authors":null,"categories":null,"date":1600214400,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1600214400,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/design-principle/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/design-principle/","section":"tags","summary":"","tags":null,"title":"Design Principle","type":"tags","url":"/ianlife/tags/design-principle/","weight":0,"wordcount":0},{"authors":null,"categories":["TECH"],"date":1600214400,"description":"迪米特法則，又稱最少知識原則。其定義為各單元對其他單元所知應當有限：只瞭解與目前單元最相關之單元。意思就是，只跟你熟的朋友聊天，不要跟陌生人講話。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":900,"keywords":["Design Pattern","Design Principle","Law of Demeter","LoD","Least Knowledge Principle","LKP","迪米特法則","最少知識原則"],"kind":"page","lang":"zh","lastmod":1600214400,"objectID":"e4df6d18cf0a5043f9a51dad36045fc2","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/law-of-demeter/","publishdate":"2020-09-16T00:00:00Z","readingtime":4,"relpermalink":"/ianlife/design-pattern/law-of-demeter/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    各單元對其他單元所知應當有限：只瞭解與目前單元最相關之單元","tags":["Design Pattern","Design Principle","鐵人賽"],"title":"迪米特法則 | Law of Demeter","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/law-of-demeter","weight":0,"wordcount":834},{"authors":null,"categories":["TECH"],"date":1600128000,"description":"合成/聚合複用原則的在於當要重複使用套件時，應該先考慮使用組合/聚合的方式，其次才是繼承。而如果要使用繼承的話，則須符合里氏替換原則(LSP)。在這之前，要先了解什麼是合成？什麼是聚合？他們又與繼承差在哪？","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":700,"keywords":["Design Pattern","Design Principle","合成複用原則","組合/聚合複用原則","CRP","CARP","Composite/Aggregate Reuse Principle","Composite Reuse Principle"],"kind":"page","lang":"zh","lastmod":1600128000,"objectID":"0d74badd154313dd7b0343caba9ee7c4","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/composite-aggregate-reuse-principle/","publishdate":"2020-09-15T00:00:00Z","readingtime":3,"relpermalink":"/ianlife/design-pattern/composite-aggregate-reuse-principle/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    盡量使用組合(contains-a)/聚合(has-a)方式來代替繼承(is-a)來達到重複使用的目的","tags":["Design Pattern","Design Principle","鐵人賽"],"title":"合成/聚合複用原則 | Composite/Aggregate Reuse Principle","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/composite-aggregate-reuse-principle","weight":0,"wordcount":632},{"authors":null,"categories":["TECH"],"date":1600041600,"description":"高層模組不應該依賴低層模組，是兩者都應該依賴抽象；而抽相不應該依賴細節，應該是細節應該依賴於抽象，這是依賴反轉原則的目的。他不但可以減低類別間的耦合，也提高了系統的可讀性及可維護性。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":400,"keywords":["Design Pattern","Design Principle","Dependency Inversion Principle","DIP","依賴反轉原則"],"kind":"page","lang":"zh","lastmod":1600041600,"objectID":"b8201c805a87ef7c2d522bf6e265dafc","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/dependence-inversion-principle/","publishdate":"2020-09-14T00:00:00Z","readingtime":2,"relpermalink":"/ianlife/design-pattern/dependence-inversion-principle/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    依賴反轉原則(DIP)的定義有兩點：","tags":["Design Pattern","Design Principle","鐵人賽"],"title":"依賴反轉原則 | Dependency Inversion Principle","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/dependence-inversion-principle","weight":0,"wordcount":377},{"authors":null,"categories":["TECH"],"date":1599955200,"description":"介面隔離原則目的在於客戶不應該被強迫依賴他們不使用的方法。如同一個公司有一般工程師及資深工程師。資深工程師可能還要囊括一些報告的工作，但一般工程師不用，這時工程師的技能分類就很重要了。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":["Design Pattern","Design Principle","Interface Segregation Principle","ISP","介面隔離原則"],"kind":"page","lang":"zh","lastmod":1599955200,"objectID":"a374670262b57aeb2538635ac9db5a68","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/interface-segregation-principle/","publishdate":"2020-09-13T00:00:00Z","readingtime":3,"relpermalink":"/ianlife/design-pattern/interface-segregation-principle/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    Clients should not be forced to depend on methods that they do not use.","tags":["Design Pattern","Design Principle","鐵人賽"],"title":"介面隔離原則 | Interface Segregation Principle","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/interface-segregation-principle","weight":0,"wordcount":479},{"authors":null,"categories":["TECH"],"date":1599868800,"description":"里氏替換原則主要在於子類別可以擴充套件父類別的功能，但不改變父類別原有的功能。就像老鷹跟企鵝都是鳥，老鷹會飛但企鵝不會。但企鵝不能去更改鳥類內的方法，只好經由其他設計達成目的。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":1100,"keywords":["Design Pattern","Design Principle","Liskov Substitution Principle","LSP","里氏替換原則"],"kind":"page","lang":"zh","lastmod":1599868800,"objectID":"cdb1958fc822d00749b856bcbea5e801","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/liskov-substitution-principle/","publishdate":"2020-09-12T00:00:00Z","readingtime":5,"relpermalink":"/ianlife/design-pattern/liskov-substitution-principle/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.","tags":["Design Pattern","Design Principle","鐵人賽"],"title":"里氏替換原則 | Liskov Substitution Principle","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/liskov-substitution-principle","weight":0,"wordcount":1061},{"authors":null,"categories":["TECH"],"date":1599782400,"description":"擴充系統時，應該由新增程式碼代替修改程式碼。如同電鑽，可以換各種不同的鑽頭，而電鑽本身並不需要被改造，就符合開閉原則。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":["Design Pattern","Design Principle","Open/Closed Principle","OCP","開閉原則"],"kind":"page","lang":"zh","lastmod":1599782400,"objectID":"baa34f00ef96fe76d2949e2dbd68c040","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/open-closed-principle/","publishdate":"2020-09-11T00:00:00Z","readingtime":3,"relpermalink":"/ianlife/design-pattern/open-closed-principle/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    Software entities like classes, modules and functions should be open for extension but closed for modifications.","tags":["Design Pattern","Design Principle","鐵人賽"],"title":"開閉原則 | Open/Closed Principle","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/open-closed-principle","weight":0,"wordcount":432},{"authors":null,"categories":["TECH"],"date":1599696000,"description":"一個類別只能有一個改變的原因。你做你該做的事，我做我該做的事。你我互不干擾，這就是單一職責原則。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":500,"keywords":["Design Pattern","Design Principle","Single Responsibility Principle","SRP","單一職責原則"],"kind":"page","lang":"zh","lastmod":1599696000,"objectID":"8f0c2397eff2ae923b68595675a999c8","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/single-responsibility-principle/","publishdate":"2020-09-10T00:00:00Z","readingtime":2,"relpermalink":"/ianlife/design-pattern/single-responsibility-principle/","section":"blog","summary":"本系列文章同步分享於IT邦幫忙第12屆鐵人賽\n   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns \u0026 Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    There should never be more than one reason for a class to change.","tags":["Design Pattern","Design Principle","鐵人賽"],"title":"單一職責原則 | Single Responsibility Principle","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/single-responsibility-principle","weight":0,"wordcount":405},{"authors":null,"categories":["TECH"],"date":1599609600,"description":"使用Design Pattern要先了解他的原則及分類，才能在實作中找到匹配的Pattern。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":400,"keywords":["Design Pattern","Design Principle","設計模式","五大基本原則","六大基本原則","七大基本原則"],"kind":"page","lang":"zh","lastmod":1599609600,"objectID":"99b3a8eaa1da2877171dbb1b73f36644","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/design-patterns-and-principle/","publishdate":"2020-09-09T00:00:00Z","readingtime":2,"relpermalink":"/ianlife/design-pattern/design-patterns-and-principle/","section":"blog","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://ithelp.ithome.com.tw/articles/10235045\" target=\"_blank\"\u003e本系列文章同步分享於IT邦幫忙第12屆鐵人賽\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cbr\u003e","tags":["Design Pattern","Design Principle","鐵人賽"],"title":"Design Pattern的類型與原則","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/design-patterns-and-principle","weight":0,"wordcount":344},{"authors":null,"categories":["TECH"],"date":1599523200,"description":"Design Pattern是解決問題的一種方案。","dir":"blog/technology/design_pattern/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":["Design Pattern","設計模式"],"kind":"page","lang":"zh","lastmod":1599523200,"objectID":"3cc58022c1e4561afd97ba91303488fc","permalink":"https://ianjustin39.github.io/ianlife/design-pattern/what_is_design_pattern/","publishdate":"2020-09-08T00:00:00Z","readingtime":2,"relpermalink":"/ianlife/design-pattern/what_is_design_pattern/","section":"blog","summary":"\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://ithelp.ithome.com.tw/articles/10234830\" target=\"_blank\"\u003e本系列文章同步分享於IT邦幫忙第12屆鐵人賽\u003c/a\u003e\u003c/strong\u003e\u003c/p\u003e\n\u003cbr\u003e\n\u003cp\u003e自從當上了工程師後，大多數時間都負責後端的程式開發，從最一開始設計api到現在sdk的經驗中，了解到一個好的程式架構及設計，不只可以讓後續維運成本降低，往後要擴充也會相對容易許多。\u003c/p\u003e","tags":["Design Pattern","鐵人賽"],"title":"什麼是Design Pattern?","type":"2020 鐵人賽 | Design Pattern","url":"/design-pattern/what_is_design_pattern","weight":0,"wordcount":226},{"authors":null,"categories":null,"date":1588723200,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1588723200,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/bootstrap/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/bootstrap/","section":"tags","summary":"","tags":null,"title":"Bootstrap","type":"tags","url":"/ianlife/tags/bootstrap/","weight":0,"wordcount":0},{"authors":null,"categories":["TECH"],"date":1588723200,"description":"","dir":"blog/technology/build_blog/","expirydate":-62135596800,"fuzzywordcount":400,"keywords":null,"kind":"page","lang":"zh","lastmod":1588723200,"objectID":"50cf604c9e0e3a107bdeaa3c0b071136","permalink":"https://ianjustin39.github.io/ianlife/build-blog/build_photograph_in_hugo/","publishdate":"2020-05-06T00:00:00Z","readingtime":2,"relpermalink":"/ianlife/build-blog/build_photograph_in_hugo/","section":"blog","summary":"\u003cp\u003e剛開始架設網站時就決定要在網站內架一個相簿，這篇會分享如何用Bootstrap+Masonry+magnificPopup建構屬於你自己的相片牆\u003c/p\u003e","tags":["Blog","Hugo","Bootstrap"],"title":"用Bootstrap + Masonry + magnific Popup架設個人相簿","type":"Blog","url":"/build-blog/build_photograph_in_hugo","weight":0,"wordcount":302},{"authors":null,"categories":null,"date":1588377600,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomy","lang":"zh","lastmod":1588377600,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/tags/github/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/tags/github/","section":"tags","summary":"","tags":null,"title":"github","type":"tags","url":"/ianlife/tags/github/","weight":0,"wordcount":0},{"authors":null,"categories":["TECH"],"date":1588377600,"description":"","dir":"blog/technology/build_blog/","expirydate":-62135596800,"fuzzywordcount":300,"keywords":null,"kind":"page","lang":"zh","lastmod":1588377600,"objectID":"cf668ef5a54071881d259c576c2ae29a","permalink":"https://ianjustin39.github.io/ianlife/build-blog/deploy_hugo_on_github/","publishdate":"2020-05-02T00:00:00Z","readingtime":2,"relpermalink":"/ianlife/build-blog/deploy_hugo_on_github/","section":"blog","summary":"\u003cp\u003e之前用Hugo架設個人網站，但架設完成後還是需要部署到一個平台，才有辦法瀏覽\u0008，\n這篇就來分享如何將網頁部署到GitHub以及途中遇到的一些問題\u003c/p\u003e","tags":["blog","github","hugo"],"title":"部署Hugo個人網頁至GitHub","type":"Blog","url":"/build-blog/deploy_hugo_on_github","weight":0,"wordcount":256},{"authors":null,"categories":null,"date":1588291200,"description":"","dir":"about/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"en","lastmod":1588291200,"objectID":"c267fa86b42e2c76a4ebaa25b13645ad","permalink":"https://ianjustin39.github.io/ianlife/en/about/","publishdate":"2020-05-01T00:00:00Z","readingtime":1,"relpermalink":"/ianlife/en/about/","section":"about","summary":"我是IAN，一名軟體工程師\nblog紀錄學習心得以防腦容量不足忘記學了什麼，同時也分享自己的人生！！\n 興趣是攝影及旅遊，也喜愛健身，目前正在朝0.5個巨巨的目標邁進\n 有時喜悅與人分享，遠比獨享還來的快樂 ｜ 謦語錄\n 若有任何問題歡迎與我聯繫！！\ngmail: ianjustin39@gmail.com\ngithub: https://github.com/ianjustin39","tags":null,"title":"About Me","type":"about","url":"/ianlife/en/about/","weight":0,"wordcount":11},{"authors":null,"categories":null,"date":1588291200,"description":"","dir":"about/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1588291200,"objectID":"a69934980f795699f7cc4d8a50a604b2","permalink":"https://ianjustin39.github.io/ianlife/about/","publishdate":"2020-05-01T00:00:00Z","readingtime":1,"relpermalink":"/ianlife/about/","section":"about","summary":"我是IAN，目前在一間區塊鏈公司擔任產品經理\n喜歡接觸各種新鮮的事物，Blog 用來紀錄學習心得以防腦容量不足忘記學了什麼，同時也分享自己的人生！！\n 興趣是攝影及旅遊，也喜愛健身，目前正在朝0.5個巨巨的目標邁進\n 有時喜悅與人分享，遠比獨享還來的快樂 ｜ 謦語錄\n 若有任何問題歡迎與我聯繫！！\ngmail: ianjustin39@gmail.com\ngithub: https://github.com/ianjustin39","tags":null,"title":"About Me","type":"about","url":"/ianlife/about/","weight":0,"wordcount":12},{"authors":null,"categories":null,"date":1588291200,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"home","lang":"en","lastmod":1588291200,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/en/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/en/","section":"","summary":"","tags":null,"title":"Life Story","type":"page","url":"/ianlife/en/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1588291200,"description":"","dir":"photograph/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"en","lastmod":1588291200,"objectID":"87a44f296cd7c3a0c8eae429d38f998c","permalink":"https://ianjustin39.github.io/ianlife/en/photograph/","publishdate":"2020-05-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/en/photograph/","section":"photograph","summary":"","tags":null,"title":"Photograph","type":"photograph","url":"/ianlife/en/photograph/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":1588291200,"description":"","dir":"photograph/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":1588291200,"objectID":"b69c5c5b426ecf644ffdce5394754260","permalink":"https://ianjustin39.github.io/ianlife/photograph/","publishdate":"2020-05-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/photograph/","section":"photograph","summary":"","tags":null,"title":"Photograph","type":"photograph","url":"/ianlife/photograph/","weight":0,"wordcount":0},{"authors":null,"categories":["TECH"],"date":1588204800,"description":"","dir":"blog/technology/build_blog/","expirydate":-62135596800,"fuzzywordcount":200,"keywords":null,"kind":"page","lang":"zh","lastmod":1588204800,"objectID":"fcee15e8a189f22cba64f5b002018f55","permalink":"https://ianjustin39.github.io/ianlife/build-blog/get_started_hugo/","publishdate":"2020-04-30T00:00:00Z","readingtime":1,"relpermalink":"/ianlife/build-blog/get_started_hugo/","section":"blog","summary":"\u003cp\u003e一直有想要寫一些文章記錄生活，身為一個工程師，難免會有想要自己架設的靈魂（？，\n最近發現hugo可以快速架站，除了有template以外也可以自己更改裡面的配置\n，對於一個前端小菜鳥來說，算是一大福音ＸＤ，於是開始了這條漫漫長路～\u003c/p\u003e","tags":["hugo","blog"],"title":"使用Hugo建立個人網頁","type":"Blog","url":"/build-blog/get_started_hugo","weight":0,"wordcount":117},{"authors":null,"categories":null,"date":-62135596800,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomyTerm","lang":"en","lastmod":-62135596800,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/en/categories/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/en/categories/","section":"categories","summary":"","tags":null,"title":"Categories","type":"categories","url":"/ianlife/en/categories/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":-62135596800,"description":"","dir":"contact/","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"section","lang":"zh","lastmod":-62135596800,"objectID":"6afdd20c496c23439408a9385435eca0","permalink":"https://ianjustin39.github.io/ianlife/contact/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/contact/","section":"contact","summary":"","tags":null,"title":"Contact","type":"contact","url":"/ianlife/contact/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":-62135596800,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomyTerm","lang":"en","lastmod":-62135596800,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/en/series/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/en/series/","section":"series","summary":"","tags":null,"title":"Series","type":"series","url":"/ianlife/en/series/","weight":0,"wordcount":0},{"authors":null,"categories":null,"date":-62135596800,"description":"","dir":"","expirydate":-62135596800,"fuzzywordcount":100,"keywords":null,"kind":"taxonomyTerm","lang":"en","lastmod":-62135596800,"objectID":"","permalink":"https://ianjustin39.github.io/ianlife/en/tags/","publishdate":"0001-01-01T00:00:00Z","readingtime":0,"relpermalink":"/ianlife/en/tags/","section":"tags","summary":"","tags":null,"title":"Tags","type":"tags","url":"/ianlife/en/tags/","weight":0,"wordcount":0}]