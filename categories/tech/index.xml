<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>TECH on Own your life</title>
    <link>https://ianjustin39.github.io/categories/tech/</link>
    <description>Recent content in TECH on Own your life</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 14 Nov 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://ianjustin39.github.io/categories/tech/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>為何交易所也推出錢包服務？</title>
      <link>https://ianjustin39.github.io/post/technology/blockchain/exchange-and-wallet/</link>
      <pubDate>Tue, 14 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/post/technology/blockchain/exchange-and-wallet/</guid>
      <description>錢包是踏入 Web3 的第一站但大家卻都選擇交易所？ 在幣圈打滾幾年的人應該都知道，如果要使用 Defi 或是進入元宇宙，都會需要自己建立一個加密貨幣的錢包，但交易所的用戶量始終大於錢包的用戶，明明錢包應該才是進入 Web3 的入口，為什麼大家卻選擇交易所呢？我認為有以下兩個原因
交易所的操作性與 web2 一樣 大部分用戶是想要『投資賺錢』 過去的 web3 因為進入門檻實在太高，再加上未知的領域太多，導致一般人很難或是很怕進入這個領域，但隨著早期貢獻者的開拓以及技術的堆疊，現在進入 web3 的門檻已經不像以前一樣那麼高，而且各種應用的出現也是為了讓圈外人可以更簡單的進入這個產業。而錢包則從早期保護資產安全到中期可以連動多種 Dapp 到現在試著融入一般現實世界的生活。雖然幣圈老屁股不斷強調 Not your key, not your crypto，一直呼籲菜鳥玩家要用錢包，把錢放在自己身上才是最安全的，連世界第二大的 FTX 都可以倒，只有把錢放在自己身上才沒有風險（還是有啊，忘記種子的話 XD），但為何大家還是去用交易所呢？
主打去中心化的優勢？但用戶只在意好不好用，賺不賺得到錢 過去 web3 產業打著『自託管』、『去中心化是未來』的口號，試圖建立大家的『正確』的知識，但就算建構者不斷地呼籲這件事，時不時還是會有新聞報出哪間交易所其實是詐騙（如 2023 年的 JPEX），散戶們損失了幾個億等等，而這類新聞只要出現，就會發現錢包商的用戶短期內會有所增長，那為何大家不一開始就使用錢包而還要去用交易所呢？
試想以前在教自己的長輩使用 Facebook 或 Line 等這些他們那個時代沒有的東西時，是不是會聽到『這太難了拉』、『你幫我設定好，讓我可以直接用』，把這個情境搬到 web3 似乎沒有違和感，『蛤建立錢包要抄註記詞喔，啊我弄丟了錢不就不見了』、『交易所可以用 google 登入誒，我用交易所就好了吧』、『我只是要買幣又沒有要玩 Dapp，交易比較方便拉』之類的聲音出現。因為自己建立錢包不但不方便，還有可能遺失『密碼』讓自己的錢不見，我只是想要投資買幣而已，與其相信自己不如相信交易所。
AA 錢包的出現讓交易所也開始推出錢包服務 EIP-4337 Account Abstraction 協議出現之後，似乎開始改變了這個窘境(網路上有很多關於 AA 提供了什麼功能，在這邊就先不細談)，在以太坊上使用 AA 錢包，體驗跟 web2 一樣，可以用手機或是 email 來建立錢包，就算丟失了帳戶的 key 也可以通過朋友或家人的錢包來為你做『社交恢復』，如此一來傳統加密貨幣錢包帶來的不便（複雜的註記詞）及風險（弄丟註記詞）在 AA 上面就被解決了。
AA 錢包的出現，也讓交易所有所警覺，先撇除交易所提供豐富的金融商品，相較於錢包，交易所的優勢在於『當用戶只是想買加密貨幣投資時，交易所有著與 web2 有著相同的用戶體驗，讓用戶可以不需要有額外的學習成本就可以持有加密貨幣』。現在 AA 錢包有著跟交易所類似的體驗，卻更忠於 web3 的去中心化的理念，用戶也可以『真正持有自己的資產』，交易所能不緊張嗎？與其把用戶拱手讓給錢包商，不如自己成為錢包商，讓用戶的資產可以『低成本的』在交易所以及自家錢包內轉換，憑藉著交易所豐富的金融商品及使用體驗來綁住這些用戶。</description>
    </item>
    
    <item>
      <title>FTX 慘劇，論去中心化的重要性，錢要放哪才是你的錢？</title>
      <link>https://ianjustin39.github.io/post/technology/blockchain/ftx-is-gone/</link>
      <pubDate>Mon, 14 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/post/technology/blockchain/ftx-is-gone/</guid>
      <description>在 2022/05 發生 Luna 崩跌事件後，當大家還覺得為什麼最近市場的波動這麼小時，全球第二大加密貨幣交易所 FTX 在上週給了大家一個驚喜，因為被爆私自挪用用戶資金，導致交易所內發生了擠兌潮，以至於 FTX 不堪負荷，不但暫停用戶提領，更在一週內宣告破產，讓許多來不及逃難的用戶資金卡在 FTX 內沒辦法拿出來。
（ 還錢～～～
FTX 相關事件的文章或分析相信在網路上搜個關鍵字都可以找到很多資訊在這就不多加敘述，而本篇要來探討的並非 FTX 倒閉，而是身在加密貨幣的世界裡，要如何選擇存放資產的位置，才不會風險發生時被當成韭菜收割。
選擇大到不會倒的交易所？ 大家在一開始接觸加密貨幣時，應該都會聽到『選一間你信任且大到不會倒的交易所，就可以開始把錢放進去買虛擬貨幣了』，相較於一些名不見經傳的交易所，世界排行前幾名的交易所的確安全許多，但 FTX 卻給了我們一個重擊，全球第二大的交易所不到一週就宣布破產，相信在 SBF 與 CZ 隔空交火時，大部分的人應該還沒想到會是這個結果。
區塊鏈的精神 - 去中心化 交易所倒閉跟去中心化又有什麼關係呢？想必有接觸過區塊鏈都聽過『去中心化』一詞，那這又代表著什麼呢？在 Web2.0 的世界裡，科技巨頭 Facebook, Google 掌握著用戶的所有資料以及生殺大權，今天只要他們認為你不合乎平台規範，他們便可以將你封鎖（想想之前川普的 twitter）；而傳統金融也是，錢讓私有銀行管理，如果銀行營運出了什麼問題導致沒辦法領出現金，那你在銀行的錢錢就只是一串數字罷了（比如說前陣子中國四大銀行無法提領現金的狀況）。而區塊鏈的其中一個精神，就是不希望有一個集團或是一個機構來『操控』這一切，你的資產讓你自己保管，鏈上一切皆由參與者來共同決定這件事。
講到這有沒有覺得，都已經投入了一個『去中心化』的世界了，卻還相信著『中心化』的機構，是不是有種矛盾的感覺？？🤣
『被管理』的資產 加密貨幣的地址是以持有的註記詞經由一連串的協議及演算法導出的一串英數字，而註記詞會交由交易保管並不會提供給用戶，用戶只會獲得每個加密貨幣的地址，提供給別人接收加密貨幣。而當要發送交易時，需要發送『申請』，等交易所同意這筆交易，用戶才能將交易發送到區塊鏈上。從頭到尾的操作，都需要經過『交易所』的同意（除了存錢以外），雖然看起來是自己決定自己的資產要做什麼，但其實所有的一切都是由交易所決定，而不是自己，哪天交易所駁回你的請求，那我們也沒辦法用其他方式拯救自己的資產。
Not Your Keys, Not Your Asset 什麼是 Key？區塊鏈的每一筆交易都需要用 private key 簽署後得到一個 signature，並將這個 signature 連同交易發送到區塊鏈上驗證。而這個 key 也是由註記詞依照一串協議及演算法推導而成。剛剛提到在交易所發送一筆交易時都需『被同意』，同意後交易所會發送一筆用『我們的 key』簽署出來的簽章及交易到鏈上，當然他也可以不同意，這樣我們就沒辦法操控自己的資產。
而這把 Key 除了放在交易所內，也可以放在加密貨幣錢包中。只要持有錢包，所有的交易都不再需要被同意，任何交易行為都掌控在自己的手上。也就是說，我們有 100% 掌控錢包內資產的權力，就算有第二個 FTX 不給用戶提領也跟我們沒有關係，因為我們的 Key 在自己的手上不需要遷就其他團體或機構。
究竟是加密貨幣不安全，還是對產業不了解？ 最後回到 FTX 事件，個人認為如果把 FTX 事件的原因歸咎於『加密貨幣就是不安全』的話，就不太合情理，畢竟中心化的機構，本來就伴隨著『人』這個最大的風險，十年夫妻也可能被戴綠帽，何況是一間交易所。不過這不代表不能把錢存在交易所內，只是做任何決定時需要知道其伴隨的風險，當風險發生時伴隨的傷害會不會影響到自己的生活甚至周遭的人，評估之下若是可以負擔的狀況，再來做這件事，不然如果心臟太小顆的話，還是把錢放在錢包內吧。</description>
    </item>
    
    <item>
      <title>幣圈黑天鵝，前十大公鏈 Terra 如何從月球殞落</title>
      <link>https://ianjustin39.github.io/post/technology/blockchain/blockchain-black-swan-terra/</link>
      <pubDate>Thu, 12 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/post/technology/blockchain/blockchain-black-swan-terra/</guid>
      <description>一個星期前，Terra 還是市值前十的加密貨幣，其中包含近期最熱門的 Defi 項目 Anchor 也是大家趨之若鶩投資的項目之一， 甚至有很多投資人把大部分資產兌換成 UST 放到 Anchor 內。 但短短的一週 Luna 的價格卻從 80 跌到0.00001 美金，Anchor 中的 UST 資金也大量的撤離， 這中間與 UST 脫鉤有著莫大的關係，一個大家都以為會成功的項目是如何在短時間內跌落谷底， 自身參與了這個幣圈的重大事件 (韭菜？)，想說來紀錄一下。
Terra 的模型 Terra 是一個擁有雙主鏈幣的區塊鏈，包含其算法穩定幣 Terra 及治理代幣 Luna，而 UST 為算法穩定幣 Terra 的一種。 由於 UST 並不像 USDC 有美元資產儲備抵押，需要依靠演算法及市場支撐與美金的掛鉤。
所以當 UST 價格高於一美元時，代表供不應求，這時便會燃燒 Luna 並鑄造 UST，讓價格回穩到一美元， 而這中間也因為 Luna 的總量變小，進而提高了 Luna 的價格。
反之，若 UST 低於一美元時，代表供過於求，這時則會燃燒 UST 去鑄造 Luna，也因為這樣 UST 的總量變小，可以讓價格回穩至一美元， 而當 UST 價格回穩後，因為 Luna 便多，所以導致 Lune 的價格下降。
這看似很合理的邏輯，似乎必須建立在市場對 Terra 有信心的情況下，Terra 才可以穩定的生存， 這也讓 Terra 埋下了一個落入死亡螺旋的不安定因素。</description>
    </item>
    
    <item>
      <title>什麼是 Blockchain Bridges，運作原理是什麼?</title>
      <link>https://ianjustin39.github.io/post/technology/blockchain/blockchain-bridge/</link>
      <pubDate>Thu, 31 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/post/technology/blockchain/blockchain-bridge/</guid>
      <description>區塊鏈技術在近幾年來成長非常的快速，最早的 Bitcoin、Ethereum 到 Binance Chain 、 Polygon 、 Solana 等，每條鏈上都有各自的治理模式、協議、規則，甚至是 Defi、NFT、DAO 等多元化的應用也相繼出現。
儘管近幾年出現的這麼多元的應用，但這些終究只能存在於單一條區塊鏈上，並沒有辦法與其他的區塊鏈互動，也就是說鏈與鏈之間並沒有互相操作性。每一條區塊鏈，就好比一座小島，試想在台灣的 Ian 想要跟在日本的 Justin 溝通訊息，該如何做到呢？現在的社會可以經由通訊軟體或是社群軟體，直接將訊息傳遞出去，也就是所謂 Web 2.0 的應用，同理，比特幣想要到以太坊上做應用，以現在的狀況來說，只有中心化交易所（還不能經由去中心化交易所 Dex）換成以太幣或是 ERC-20 token 才有辦法做到這件事。但若這樣操作手上便不在持有比特幣，這也跟當初想要以『比特幣在以太坊上做應用』的想法有所差異。
什麼是 Bridges，運作原理是什麼？ 先來講講什麼是 Blockchain Bridge ，它是以什麼方式來解決互相操作性的問題。Bridge 允許兩條不同規則、不同協議的區塊鏈將他們的數據、代幣互相傳遞。以上述的例子來講，可以不經由交易所得換幣服務，直接再以太坊上使用自己持有的比特幣。
在你希望將自己的一部分比特幣轉移到以太坊上時， Blockchain Bridge 會先將你比特幣鎖在所使用的 Bridge 上，並在以太坊上建立等同價值的比特幣代幣（稱作 wBTC），此時便可以使用 wBTC 去操作以太坊上的 Dapp 。相反，當你認為不需要繼續在以太坊上，想要換回比特幣時，只需要做反向的行為，以太坊上的 wBTC 會被燒毀，而同等價值的比特幣則會回到你的手上。但必須注意的是，若用 Bridge 將 10 BTC 換成 10 wBTC，換回時卻只有 9 wBTC 的話，也只能取得 9 BTC。
簡單來說，經由 Bridge 是將你的加密貨幣『複製』一份到別條鏈上，讓他符合另一條鏈的規範與協議，可以操作上面的各種應用。
Bridges 種類 Bridges 又分為 One-Way Bridges &amp;amp; Two-Way Bridges，以及 Trust-Based &amp;amp; Trustless Bridges。</description>
    </item>
    
    <item>
      <title>無視礦工，以太坊的倫敦硬分叉</title>
      <link>https://ianjustin39.github.io/post/technology/blockchain/ethereum-london-hard-fork/</link>
      <pubDate>Wed, 16 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/post/technology/blockchain/ethereum-london-hard-fork/</guid>
      <description>前言 現今以太坊的手續費過於昂貴，交易者需要付出高額的手續費才可以完成交易。 這次的 Ethereum London Hard Fork （倫敦硬分叉）所做的更新，包含了 EIP-1559、EIP-3198、EIP-3238 三個提案， 其中 EIP-1559 也是這次比較備受關注的部分。
EIP 是什麼？ EIP(Ethereum Improvement Proposals)，是為以太坊指定潛在新功能或流程的標準，包含提議更改的技術規範。通過 EIP 流程討論和開發以太坊的網絡升級和應用標準。
提案一： EIP-1559（區塊鏈交易費用模型） EIP-1559 是對用戶在以太坊網絡上支付 gas 費用方式的更改。（由於現在以太坊交易手續費過高，降低對用戶的吸引力）
以往：礦工可以賺的收入「挖礦獎勵」跟「 100% Gas fee 」 EIP 1559 ： gas fee 分為基礎費（base fee）和小費兩種，給礦工的是「小費」； base fee 的 50% 會直接銷毀。 EIP-1559 也導入目標塊容量機制，每個區塊的基本費用根據網絡需求而變化。如果一個區塊的交易量超過 50%，則基本費用將增加，低於 50% 的話基本費則會下降。 而基本費可能會隨著交易加入 block 時發生改變，可以先將 price 設定成願意支付的上限，最後沒用到的部分會退還。
這個提案重點在於基本費會被銷毀，並不會所有的 gas fee 都讓礦工拿走。而也藉由『銷毀』機制，讓以太幣的供應量下降，避免通貨膨脹。
交易格式的差異 以下部分段程式碼是從 EIP-1559 擷取。
新交易格式內的 base_fee_per_gas ＆ priority_fee_per_gas 取代了以往的 Legacy Ethereum transactions 的 gas_price。 但 EIP-1559 可以相容 Legacy Ethereum transactions 的格式。 雖然現有的交易格式仍然有效且也被包含在 block 中，不過 Legacy transactions 沒辦法享有新的 pricing system 所帶來的優點。</description>
    </item>
    
    <item>
      <title>快速排序 - Quick Sort</title>
      <link>https://ianjustin39.github.io/algorithms/quick-sort/</link>
      <pubDate>Wed, 17 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/algorithms/quick-sort/</guid>
      <description></description>
    </item>
    
    <item>
      <title>合併排序 - Merge Sort</title>
      <link>https://ianjustin39.github.io/algorithms/merge-sort/</link>
      <pubDate>Tue, 16 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/algorithms/merge-sort/</guid>
      <description></description>
    </item>
    
    <item>
      <title>泡沫排序 - Bubble Sort</title>
      <link>https://ianjustin39.github.io/algorithms/bubble-sort/</link>
      <pubDate>Mon, 15 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/algorithms/bubble-sort/</guid>
      <description></description>
    </item>
    
    <item>
      <title>在 Hugo Blog 中加上 Algolia 文章搜索工具</title>
      <link>https://ianjustin39.github.io/build-blog/hugo-and-algolia/</link>
      <pubDate>Sat, 13 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/build-blog/hugo-and-algolia/</guid>
      <description>隨著文章越來越多，要找到以前寫的文章就越來越麻煩，所以就一直想尋找站內搜索的功能使用。之前有試用 google 的站內搜索功能，但總覺得整體不是很好看，也就沒有繼續使用。直到最近看到 Algolia ，可建立文章的索引，將資料上傳到 Algolia，再藉由串接 API 就可以完成搜索功能。
接下來就開始建立站內搜索功能吧。
註冊 Algolia 第一步就是要到 Algolia 註冊帳號，登入後會要求輸入一個 index（等等要用到這個 index），然後會以這個 index 建立一個 app ，接著選擇存取的國家（我是選日本），完成之後會有這個畫面。
然後點選左邊的 API Keys，這邊有等等設定需要使用的參數，可以先將他們記下來。
註：Algolia 有分幾個付費等級，現在有 15 天試用期，不過因為 blog 只需要簡單的搜索文章的功能，這裡目前是使用免費版，若要更進階的功能可以自行研究看看。
hugo 生成索引文件 1. 修改 config.toml 修改./config.toml設定好需要的參數。
[outputs] home = [&amp;#34;HTML&amp;#34;, &amp;#34;RSS&amp;#34;, &amp;#34;Algolia&amp;#34;] [outputFormats.Algolia] baseName = &amp;#34;algolia&amp;#34; isPlainText = true mediaType = &amp;#34;application/json&amp;#34; notAlternative = true [params.algolia] appId = &amp;#34;剛剛看到的 ID&amp;#34; indexName = &amp;#34;一開始輸入的 index&amp;#34; searchOnlyKey = &amp;#34;剛剛看到的 Search Only Key&amp;#34; vars = [&amp;#34;title&amp;#34;, &amp;#34;summary&amp;#34;, &amp;#34;date&amp;#34;, &amp;#34;publishdate&amp;#34;, &amp;#34;expirydate&amp;#34;, &amp;#34;permalink&amp;#34;] params = [&amp;#34;categories&amp;#34;, &amp;#34;tags&amp;#34;, &amp;#34;series&amp;#34;] 2.</description>
    </item>
    
    <item>
      <title>字典樹 - Trie</title>
      <link>https://ianjustin39.github.io/algorithms/tries/</link>
      <pubDate>Tue, 09 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/algorithms/tries/</guid>
      <description></description>
    </item>
    
    <item>
      <title>二分搜尋演算法 (Binary search algorithm) - 終極密碼</title>
      <link>https://ianjustin39.github.io/algorithms/binary-search/</link>
      <pubDate>Sun, 07 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/algorithms/binary-search/</guid>
      <description>&lt;p&gt;&lt;!-- raw HTML omitted --&gt;圖片來源&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>策略模式 | Strategy Pattern</title>
      <link>https://ianjustin39.github.io/design-pattern/strategy-pattern/</link>
      <pubDate>Tue, 06 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/design-pattern/strategy-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
Design Pattern 系列文章導讀 Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE 設計模式 - 入門篇 什麼是Design Pattern? Design Pattern的類型與原則 設計模式 - 原則篇 | Design Principles 單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter 設計模式 - 創建型模型篇 | Creational Patterns 單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern 設計模式 - 結構型模型篇 | Structural Patterns 適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern 設計模式 - 行為型模型篇 | Behavioural Patterns 責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern 設計模式 - 番外篇 Anti-Patterns Code Smells Design Pattern VS 演算法 定義 定義一系列演算法，並將其封裝起來，使他們可以相互替換，演算法的變換不影響使用。</description>
    </item>
    
    <item>
      <title>觀察者模式 | Observer Pattern</title>
      <link>https://ianjustin39.github.io/design-pattern/observer-pattern/</link>
      <pubDate>Mon, 05 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/design-pattern/observer-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
Design Pattern 系列文章導讀 Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE 設計模式 - 入門篇 什麼是Design Pattern? Design Pattern的類型與原則 設計模式 - 原則篇 | Design Principles 單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter 設計模式 - 創建型模型篇 | Creational Patterns 單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern 設計模式 - 結構型模型篇 | Structural Patterns 適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern 設計模式 - 行為型模型篇 | Behavioural Patterns 責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern 設計模式 - 番外篇 Anti-Patterns Code Smells Design Pattern VS 演算法 定義 多個物件之間存在著一對多的依賴關係，當一個物件發生改變時，所有跟他有關的物件都會被通知且更新。</description>
    </item>
    
    <item>
      <title>備忘錄模式 | Memento Pattern</title>
      <link>https://ianjustin39.github.io/design-pattern/memento-pattern/</link>
      <pubDate>Sun, 04 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/design-pattern/memento-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
Design Pattern 系列文章導讀 Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE 設計模式 - 入門篇 什麼是Design Pattern? Design Pattern的類型與原則 設計模式 - 原則篇 | Design Principles 單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter 設計模式 - 創建型模型篇 | Creational Patterns 單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern 設計模式 - 結構型模型篇 | Structural Patterns 適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern 設計模式 - 行為型模型篇 | Behavioural Patterns 責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern 設計模式 - 番外篇 Anti-Patterns Code Smells Design Pattern VS 演算法 定義 在不破壞封裝的前提下，儲存一個物件的某個狀態，以便於需要的時候將物件恢復到原先儲存的狀態。</description>
    </item>
    
    <item>
      <title>狀態模式 | State Pattern</title>
      <link>https://ianjustin39.github.io/design-pattern/state-pattern/</link>
      <pubDate>Sat, 03 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/design-pattern/state-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
Design Pattern 系列文章導讀 Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE 設計模式 - 入門篇 什麼是Design Pattern? Design Pattern的類型與原則 設計模式 - 原則篇 | Design Principles 單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter 設計模式 - 創建型模型篇 | Creational Patterns 單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern 設計模式 - 結構型模型篇 | Structural Patterns 適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern 設計模式 - 行為型模型篇 | Behavioural Patterns 責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern 設計模式 - 番外篇 Anti-Patterns Code Smells Design Pattern VS 演算法 定義 有狀態的物件，把複雜的邏輯判斷分配到不同的狀態物件中，允許狀態物件在其內部狀態發生改變時改變行為。</description>
    </item>
    
    <item>
      <title>中介者模式 | Mediator Pattern</title>
      <link>https://ianjustin39.github.io/design-pattern/mediator-pattern/</link>
      <pubDate>Fri, 02 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/design-pattern/mediator-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
Design Pattern 系列文章導讀 Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE 設計模式 - 入門篇 什麼是Design Pattern? Design Pattern的類型與原則 設計模式 - 原則篇 | Design Principles 單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter 設計模式 - 創建型模型篇 | Creational Patterns 單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern 設計模式 - 結構型模型篇 | Structural Patterns 適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern 設計模式 - 行為型模型篇 | Behavioural Patterns 責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern 設計模式 - 番外篇 Anti-Patterns Code Smells Design Pattern VS 演算法 定義 定義一個 Mediator 物件用來封裝一組物件的互動方式。Mediator 藉由避免物件間相互直接的引用，從而降低它們之間的耦合程度，並且可以讓我們獨立地改變這些物件間的互動方式。</description>
    </item>
    
    <item>
      <title>迭代器模式 | Iterator Pattern</title>
      <link>https://ianjustin39.github.io/design-pattern/iterator-pattern/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/design-pattern/iterator-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
Design Pattern 系列文章導讀 Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE 設計模式 - 入門篇 什麼是Design Pattern? Design Pattern的類型與原則 設計模式 - 原則篇 | Design Principles 單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter 設計模式 - 創建型模型篇 | Creational Patterns 單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern 設計模式 - 結構型模型篇 | Structural Patterns 適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern 設計模式 - 行為型模型篇 | Behavioural Patterns 責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern 設計模式 - 番外篇 Anti-Patterns Code Smells Design Pattern VS 演算法 定義 提供一種方法可以順序性讀取一個集合物件中的各個元素，而又不會暴露該物件的內部表示。</description>
    </item>
    
    <item>
      <title>命令模式 | Command Pattern</title>
      <link>https://ianjustin39.github.io/design-pattern/command-pattern/</link>
      <pubDate>Wed, 30 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/design-pattern/command-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
Design Pattern 系列文章導讀 Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE 設計模式 - 入門篇 什麼是Design Pattern? Design Pattern的類型與原則 設計模式 - 原則篇 | Design Principles 單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter 設計模式 - 創建型模型篇 | Creational Patterns 單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern 設計模式 - 結構型模型篇 | Structural Patterns 適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern 設計模式 - 行為型模型篇 | Behavioural Patterns 責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern 設計模式 - 番外篇 Anti-Patterns Code Smells Design Pattern VS 演算法 定義 The Command Pattern encapsulates a request as an object, thereby letting you parameterize other objects with different requests, queue or log requests, and support undoable operations.</description>
    </item>
    
    <item>
      <title>責任鏈模式 | Chain of Responsibility Pattern</title>
      <link>https://ianjustin39.github.io/design-pattern/chain-of-responsibility/</link>
      <pubDate>Tue, 29 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/design-pattern/chain-of-responsibility/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
Design Pattern 系列文章導讀 Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE 設計模式 - 入門篇 什麼是Design Pattern? Design Pattern的類型與原則 設計模式 - 原則篇 | Design Principles 單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter 設計模式 - 創建型模型篇 | Creational Patterns 單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern 設計模式 - 結構型模型篇 | Structural Patterns 適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern 設計模式 - 行為型模型篇 | Behavioural Patterns 責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern 設計模式 - 番外篇 Anti-Patterns Code Smells Design Pattern VS 演算法 定義 將多個物件連成一條鏈，沿著這條鏈傳遞至每一個物件並處理請求。</description>
    </item>
    
    <item>
      <title>代理模式 | Proxy Pattern</title>
      <link>https://ianjustin39.github.io/design-pattern/proxy-pattern/</link>
      <pubDate>Mon, 28 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/design-pattern/proxy-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
Design Pattern 系列文章導讀 Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE 設計模式 - 入門篇 什麼是Design Pattern? Design Pattern的類型與原則 設計模式 - 原則篇 | Design Principles 單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter 設計模式 - 創建型模型篇 | Creational Patterns 單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern 設計模式 - 結構型模型篇 | Structural Patterns 適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern 設計模式 - 行為型模型篇 | Behavioural Patterns 責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern 設計模式 - 番外篇 Anti-Patterns Code Smells Design Pattern VS 演算法 定義 爲其他物件提供一種代理以控制對這個物件的訪問。</description>
    </item>
    
    <item>
      <title>享元模式 | Flyweight Pattern</title>
      <link>https://ianjustin39.github.io/design-pattern/flyweight-pattern/</link>
      <pubDate>Sun, 27 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/design-pattern/flyweight-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
Design Pattern 系列文章導讀 Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE 設計模式 - 入門篇 什麼是Design Pattern? Design Pattern的類型與原則 設計模式 - 原則篇 | Design Principles 單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter 設計模式 - 創建型模型篇 | Creational Patterns 單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern 設計模式 - 結構型模型篇 | Structural Patterns 適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern 設計模式 - 行為型模型篇 | Behavioural Patterns 責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern 設計模式 - 番外篇 Anti-Patterns Code Smells Design Pattern VS 演算法 定義 運用共享技術有效地支持大量細粒度的物件。</description>
    </item>
    
    <item>
      <title>外觀模式 | Facade Pattern</title>
      <link>https://ianjustin39.github.io/design-pattern/facede-pattern/</link>
      <pubDate>Sat, 26 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/design-pattern/facede-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
Design Pattern 系列文章導讀 Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE 設計模式 - 入門篇 什麼是Design Pattern? Design Pattern的類型與原則 設計模式 - 原則篇 | Design Principles 單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter 設計模式 - 創建型模型篇 | Creational Patterns 單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern 設計模式 - 結構型模型篇 | Structural Patterns 適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern 設計模式 - 行為型模型篇 | Behavioural Patterns 責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern 設計模式 - 番外篇 Anti-Patterns Code Smells Design Pattern VS 演算法 定義 為子系統中的一組接口提供一個統一的高層接口，使得子系統更容易使用。</description>
    </item>
    
    <item>
      <title>裝飾者模式 | Decorator Pattern</title>
      <link>https://ianjustin39.github.io/design-pattern/decorator-pattern/</link>
      <pubDate>Fri, 25 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/design-pattern/decorator-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
Design Pattern 系列文章導讀 Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE 設計模式 - 入門篇 什麼是Design Pattern? Design Pattern的類型與原則 設計模式 - 原則篇 | Design Principles 單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter 設計模式 - 創建型模型篇 | Creational Patterns 單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern 設計模式 - 結構型模型篇 | Structural Patterns 適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern 設計模式 - 行為型模型篇 | Behavioural Patterns 責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern 設計模式 - 番外篇 Anti-Patterns Code Smells Design Pattern VS 演算法 定義 裝飾模式動態將責任附加在物件上，若要擴展功能上，裝飾者提供比繼承更有彈性的替代方案。</description>
    </item>
    
    <item>
      <title>组合模式 | Composite Pattern</title>
      <link>https://ianjustin39.github.io/design-pattern/composite-pattern/</link>
      <pubDate>Thu, 24 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/design-pattern/composite-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
Design Pattern 系列文章導讀 Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE 設計模式 - 入門篇 什麼是Design Pattern? Design Pattern的類型與原則 設計模式 - 原則篇 | Design Principles 單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter 設計模式 - 創建型模型篇 | Creational Patterns 單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern 設計模式 - 結構型模型篇 | Structural Patterns 適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern 設計模式 - 行為型模型篇 | Behavioural Patterns 責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern 設計模式 - 番外篇 Anti-Patterns Code Smells Design Pattern VS 演算法 定義 物件以樹狀結構組合，做為表現出整體-部分的階層關係。</description>
    </item>
    
    <item>
      <title>橋接模式 | Bridge Pattern</title>
      <link>https://ianjustin39.github.io/design-pattern/bridge-pattern/</link>
      <pubDate>Wed, 23 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/design-pattern/bridge-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
Design Pattern 系列文章導讀 Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE 設計模式 - 入門篇 什麼是Design Pattern? Design Pattern的類型與原則 設計模式 - 原則篇 | Design Principles 單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter 設計模式 - 創建型模型篇 | Creational Patterns 單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern 設計模式 - 結構型模型篇 | Structural Patterns 適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern 設計模式 - 行為型模型篇 | Behavioural Patterns 責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern 設計模式 - 番外篇 Anti-Patterns Code Smells Design Pattern VS 演算法 定義 將抽象部分與實現部分分離，使它們都可以獨立的變化。</description>
    </item>
    
    <item>
      <title>適配器模式 | Adapter Pattern</title>
      <link>https://ianjustin39.github.io/design-pattern/adapter-pattern/</link>
      <pubDate>Tue, 22 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/design-pattern/adapter-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
Design Pattern 系列文章導讀 Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE 設計模式 - 入門篇 什麼是Design Pattern? Design Pattern的類型與原則 設計模式 - 原則篇 | Design Principles 單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter 設計模式 - 創建型模型篇 | Creational Patterns 單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern 設計模式 - 結構型模型篇 | Structural Patterns 適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern 設計模式 - 行為型模型篇 | Behavioural Patterns 責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern 設計模式 - 番外篇 Anti-Patterns Code Smells Design Pattern VS 演算法 定義 The Adapter Pattern converts the interface of a class into another interface the clients expect.</description>
    </item>
    
    <item>
      <title>原型模式 | Prototype Pattern</title>
      <link>https://ianjustin39.github.io/design-pattern/prototype-pattern/</link>
      <pubDate>Mon, 21 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/design-pattern/prototype-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
Design Pattern 系列文章導讀 Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE 設計模式 - 入門篇 什麼是Design Pattern? Design Pattern的類型與原則 設計模式 - 原則篇 | Design Principles 單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter 設計模式 - 創建型模型篇 | Creational Patterns 單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern 設計模式 - 結構型模型篇 | Structural Patterns 適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern 設計模式 - 行為型模型篇 | Behavioural Patterns 責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern 設計模式 - 番外篇 Anti-Patterns Code Smells Design Pattern VS 演算法 定義 用原型例項指定建立物件的種類，並且通過拷貝這些原型建立新的物件。</description>
    </item>
    
    <item>
      <title>生成器模式 | Builder Pattern</title>
      <link>https://ianjustin39.github.io/design-pattern/builder-pattern/</link>
      <pubDate>Sun, 20 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/design-pattern/builder-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
Design Pattern 系列文章導讀 Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE 設計模式 - 入門篇 什麼是Design Pattern? Design Pattern的類型與原則 設計模式 - 原則篇 | Design Principles 單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter 設計模式 - 創建型模型篇 | Creational Patterns 單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern 設計模式 - 結構型模型篇 | Structural Patterns 適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern 設計模式 - 行為型模型篇 | Behavioural Patterns 責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern 設計模式 - 番外篇 Anti-Patterns Code Smells Design Pattern VS 演算法 定義 把一個複雜物件的建構與樣貌分離，如此相同的建構過程可以產生不同樣貌的物件</description>
    </item>
    
    <item>
      <title>抽象工廠模式 | Abstract Factory Pattern</title>
      <link>https://ianjustin39.github.io/design-pattern/abstract-factory-pattern/</link>
      <pubDate>Sat, 19 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/design-pattern/abstract-factory-pattern/</guid>
      <description></description>
    </item>
    
    <item>
      <title>工廠模式 | Factory Pattern</title>
      <link>https://ianjustin39.github.io/design-pattern/factory-pattern/</link>
      <pubDate>Fri, 18 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/design-pattern/factory-pattern/</guid>
      <description></description>
    </item>
    
    <item>
      <title>單例模式 | Singleton Pattern</title>
      <link>https://ianjustin39.github.io/design-pattern/singleton-pattern/</link>
      <pubDate>Thu, 17 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/design-pattern/singleton-pattern/</guid>
      <description></description>
    </item>
    
    <item>
      <title>迪米特法則 | Law of Demeter</title>
      <link>https://ianjustin39.github.io/design-pattern/law-of-demeter/</link>
      <pubDate>Wed, 16 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/design-pattern/law-of-demeter/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
Design Pattern 系列文章導讀 Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE 設計模式 - 入門篇 什麼是Design Pattern? Design Pattern的類型與原則 設計模式 - 原則篇 | Design Principles 單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter 設計模式 - 創建型模型篇 | Creational Patterns 單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern 設計模式 - 結構型模型篇 | Structural Patterns 適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern 設計模式 - 行為型模型篇 | Behavioural Patterns 責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern 設計模式 - 番外篇 Anti-Patterns Code Smells Design Pattern VS 演算法 定義 各單元對其他單元所知應當有限：只瞭解與目前單元最相關之單元</description>
    </item>
    
    <item>
      <title>合成/聚合複用原則 | Composite/Aggregate Reuse Principle</title>
      <link>https://ianjustin39.github.io/design-pattern/composite-aggregate-reuse-principle/</link>
      <pubDate>Tue, 15 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/design-pattern/composite-aggregate-reuse-principle/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
Design Pattern 系列文章導讀 Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE 設計模式 - 入門篇 什麼是Design Pattern? Design Pattern的類型與原則 設計模式 - 原則篇 | Design Principles 單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter 設計模式 - 創建型模型篇 | Creational Patterns 單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern 設計模式 - 結構型模型篇 | Structural Patterns 適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern 設計模式 - 行為型模型篇 | Behavioural Patterns 責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern 設計模式 - 番外篇 Anti-Patterns Code Smells Design Pattern VS 演算法 定義 盡量使用組合(contains-a)/聚合(has-a)方式來代替繼承(is-a)來達到重複使用的目的</description>
    </item>
    
    <item>
      <title>依賴反轉原則 | Dependency Inversion Principle</title>
      <link>https://ianjustin39.github.io/design-pattern/dependence-inversion-principle/</link>
      <pubDate>Mon, 14 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/design-pattern/dependence-inversion-principle/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
Design Pattern 系列文章導讀 Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE 設計模式 - 入門篇 什麼是Design Pattern? Design Pattern的類型與原則 設計模式 - 原則篇 | Design Principles 單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter 設計模式 - 創建型模型篇 | Creational Patterns 單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern 設計模式 - 結構型模型篇 | Structural Patterns 適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern 設計模式 - 行為型模型篇 | Behavioural Patterns 責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern 設計模式 - 番外篇 Anti-Patterns Code Smells Design Pattern VS 演算法 定義 依賴反轉原則(DIP)的定義有兩點：</description>
    </item>
    
    <item>
      <title>介面隔離原則 | Interface Segregation Principle</title>
      <link>https://ianjustin39.github.io/design-pattern/interface-segregation-principle/</link>
      <pubDate>Sun, 13 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/design-pattern/interface-segregation-principle/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
Design Pattern 系列文章導讀 Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE 設計模式 - 入門篇 什麼是Design Pattern? Design Pattern的類型與原則 設計模式 - 原則篇 | Design Principles 單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter 設計模式 - 創建型模型篇 | Creational Patterns 單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern 設計模式 - 結構型模型篇 | Structural Patterns 適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern 設計模式 - 行為型模型篇 | Behavioural Patterns 責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern 設計模式 - 番外篇 Anti-Patterns Code Smells Design Pattern VS 演算法 定義 Clients should not be forced to depend on methods that they do not use.</description>
    </item>
    
    <item>
      <title>里氏替換原則 | Liskov Substitution Principle</title>
      <link>https://ianjustin39.github.io/design-pattern/liskov-substitution-principle/</link>
      <pubDate>Sat, 12 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/design-pattern/liskov-substitution-principle/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
Design Pattern 系列文章導讀 Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE 設計模式 - 入門篇 什麼是Design Pattern? Design Pattern的類型與原則 設計模式 - 原則篇 | Design Principles 單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter 設計模式 - 創建型模型篇 | Creational Patterns 單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern 設計模式 - 結構型模型篇 | Structural Patterns 適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern 設計模式 - 行為型模型篇 | Behavioural Patterns 責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern 設計模式 - 番外篇 Anti-Patterns Code Smells Design Pattern VS 演算法 定義 If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.</description>
    </item>
    
    <item>
      <title>開閉原則 | Open/Closed Principle</title>
      <link>https://ianjustin39.github.io/design-pattern/open-closed-principle/</link>
      <pubDate>Fri, 11 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/design-pattern/open-closed-principle/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
Design Pattern 系列文章導讀 Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE 設計模式 - 入門篇 什麼是Design Pattern? Design Pattern的類型與原則 設計模式 - 原則篇 | Design Principles 單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter 設計模式 - 創建型模型篇 | Creational Patterns 單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern 設計模式 - 結構型模型篇 | Structural Patterns 適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern 設計模式 - 行為型模型篇 | Behavioural Patterns 責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern 設計模式 - 番外篇 Anti-Patterns Code Smells Design Pattern VS 演算法 定義 Software entities like classes, modules and functions should be open for extension but closed for modifications.</description>
    </item>
    
    <item>
      <title>單一職責原則 | Single Responsibility Principle</title>
      <link>https://ianjustin39.github.io/design-pattern/single-responsibility-principle/</link>
      <pubDate>Thu, 10 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/design-pattern/single-responsibility-principle/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
Design Pattern 系列文章導讀 Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE 設計模式 - 入門篇 什麼是Design Pattern? Design Pattern的類型與原則 設計模式 - 原則篇 | Design Principles 單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter 設計模式 - 創建型模型篇 | Creational Patterns 單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern 設計模式 - 結構型模型篇 | Structural Patterns 適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern 設計模式 - 行為型模型篇 | Behavioural Patterns 責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern 設計模式 - 番外篇 Anti-Patterns Code Smells Design Pattern VS 演算法 定義 There should never be more than one reason for a class to change.</description>
    </item>
    
    <item>
      <title>Design Pattern的類型與原則</title>
      <link>https://ianjustin39.github.io/design-pattern/design-patterns-and-principle/</link>
      <pubDate>Wed, 09 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/design-pattern/design-patterns-and-principle/</guid>
      <description>&lt;p&gt;&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;本系列文章同步分享於IT邦幫忙第12屆鐵人賽&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;</description>
    </item>
    
    <item>
      <title>什麼是Design Pattern?</title>
      <link>https://ianjustin39.github.io/design-pattern/what_is_design_pattern/</link>
      <pubDate>Tue, 08 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/design-pattern/what_is_design_pattern/</guid>
      <description>&lt;p&gt;&lt;strong&gt;&lt;!-- raw HTML omitted --&gt;本系列文章同步分享於IT邦幫忙第12屆鐵人賽&lt;!-- raw HTML omitted --&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;自從當上了工程師後，大多數時間都負責後端的程式開發，從最一開始設計api到現在sdk的經驗中，了解到一個好的程式架構及設計，不只可以讓後續維運成本降低，往後要擴充也會相對容易許多。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>用Bootstrap &#43; Masonry &#43; magnific Popup架設個人相簿</title>
      <link>https://ianjustin39.github.io/build-blog/build_photograph_in_hugo/</link>
      <pubDate>Wed, 06 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/build-blog/build_photograph_in_hugo/</guid>
      <description>&lt;p&gt;剛開始架設網站時就決定要在網站內架一個相簿，這篇會分享如何用Bootstrap+Masonry+magnificPopup建構屬於你自己的相片牆&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>部署Hugo個人網頁至GitHub</title>
      <link>https://ianjustin39.github.io/build-blog/deploy_hugo_on_github/</link>
      <pubDate>Sat, 02 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/build-blog/deploy_hugo_on_github/</guid>
      <description>&lt;p&gt;之前用Hugo架設個人網站，但架設完成後還是需要部署到一個平台，才有辦法瀏覽，
這篇就來分享如何將網頁部署到GitHub以及途中遇到的一些問題&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用Hugo建立個人網頁</title>
      <link>https://ianjustin39.github.io/build-blog/get_started_hugo/</link>
      <pubDate>Thu, 30 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/build-blog/get_started_hugo/</guid>
      <description>&lt;p&gt;一直有想要寫一些文章記錄生活，身為一個工程師，難免會有想要自己架設的靈魂（？，
最近發現hugo可以快速架站，除了有template以外也可以自己更改裡面的配置
，對於一個前端小菜鳥來說，算是一大福音ＸＤ，於是開始了這條漫漫長路～&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
