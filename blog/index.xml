<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog on Life Story</title>
    <link>https://ianjustin39.github.io/ianlife/blog/</link>
    <description>Recent content in Blog on Life Story</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Mon, 11 Oct 2021 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://ianjustin39.github.io/ianlife/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Polkadot Parse</title>
      <link>https://ianjustin39.github.io/ianlife/blog/technology/blockchain/blockchain/polkadot/</link>
      <pubDate>Mon, 11 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/blog/technology/blockchain/blockchain/polkadot/</guid>
      <description>What is DOT? DOT is the native token of the Polkadot network in a similar way that BTC is the native token of Bitcoin or ether is the native token of the Ethereum blockchain.
The smallest unit of account in a Substrate network (Polkadot, Kusama, etc.) is the Planck. Kusama tokens (KSM) are equal to 1e12 Planck, and Polkadot mainnet DOT are equal to 1e10 Planck.
1 Dot (DOT) = 10000000000 Planck</description>
    </item>
    
    <item>
      <title>大人的11堂寫作課 - 複利成長自身的價值</title>
      <link>https://ianjustin39.github.io/ianlife/read/11-writing-lesson/</link>
      <pubDate>Sat, 24 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/read/11-writing-lesson/</guid>
      <description>為什麼要寫作？  寫作可以重複銷售自己的時間  一個人最簡單的商業模式，就是販售時間，比方說：上班就是把自己的時間賣給老闆賺取薪水。 而在這模式中，又可分為三種類型，同一份時間出售一次、重複出售同一份時間、購買他人的時間再出售。 絕大多數的人都是第一種，少部分是第三種。而我們則可以靠自身優化從第一種進化成第二種。
舉個簡單的例子，今天要分享故事，與多人分享的效率一定比只跟一個人講高。 但如果另一群人要聽，又要再講一次，等於要再花一次的時間。 是把演講的內容寫成一篇完整的文章，今天會有人看，明天也會有人看，甚至一年後也會有人看。 但並不需要再花時間做一次演講，這就是將時間重複銷售。
寫的爛才要開始寫 『我覺得我寫的很爛，等進步了我在開始寫』，這是多數人不敢開始寫作的理由。但應該是因為寫的差，所以要從現在開始練習寫。 想想我們在做任何改變或是學習之前，應該都有『我這方面就是比較差，所以要開始練習』的認知，寫作也一樣， 應該是『我覺得我寫不好，所以現在要開始練習寫作』。 所以如何踏出寫作的第一步。就是先認清『自己暫時寫的差』的這個事實。
先寫好一段話 寫作的第一步，並不是寫長篇文章，而是先寫好一段話。比方說從『無限賽局』中學到了什麼事有限思維以及無限思維， 一開始就要寫一篇關於無限思維的文章困難度非常高，但可以先從一段文字開始，試著用幾句話向別人解釋什麼是無限思維。 『原子習慣』一書中提到『最小努力原則』，意思是讓習慣簡單到就算沒意願也會執行，難度越低，執行起來越容易。 比方說，今天看完一部電影，要直接寫出影評太困難，但可以先寫 50~100 字的觀後心得。 持續練習下來會發現，300~400 的文章已經可以輕鬆地寫出來，直到有一天就可以寫出一篇完整的觀後影評。
寫作的核心：輸入、思考、輸出  寫作不外乎就是，想到東西、整理思緒、寫下來。看似簡單的幾個動作，其中卻有不簡單的道理。 例如：
 想寫一篇政治的文章，但一個沒看過新聞的人，怎麼寫得出來呢？『輸入』的重要性。 平時常常在看新聞，但只是邊看邊跟著罵政府，那能寫出什麼東西呢？『思考』的重要性。 平時都有看新聞，也有經過獨立思考了，終於拿起筆，但卻不知道要寫什麼，該怎麼辦？『輸出』能力。  接下來接著深入探討如何有效的『輸入』、『思考』、『輸出』。
輸入 要長期且穩定有高品質的輸出，就需要不斷的接收新資訊、新觀點，所以輸入的方法就很重要，可以用以下三種方法來提升我們輸入的能力。
 強度：『沒數量就沒品質』，兩人能力相當的情況下，一年讀五百萬字和一年五十萬字的人，寫作能力就會有極大的差距。 標準：『8 星 &amp;gt; 6 星』，寧可多花一些時間去查詢評價，也不要直接去看一部沒什麼重點的爛片（不一定是影集）。 效果：『吸收 &amp;gt; 完成』，完成不是重點，重點是有沒有吸收。比方說同樣是讀書，有的人目標是『讀完』，有的人目標是『將書中的知識運用在工作上』。  思考 必須要將輸入的資訊整理清楚，才有辦法有效的輸出成文字，
 追問：不管遇到什麼問題，都要有追根究底的精神。 建立連結：試著將學到的知識互相建立關係。例如：從寫好一句話開始 -&amp;gt; 原子習慣中的『最小努力原則』。 應用：將所學的東西實際應用出來。  輸出 有不斷的輸入、不斷的思考，最後就是如何把素材輸出成一篇文章，作者提供了以下四種方法來練習寫作：
 就是寫：就是不會，才要『刻意練習』。如同開頭講的，可以從一段話開始慢慢練習。 學寫故事、觀點：故事及觀點可以讓我們思考文章如何呈現給讀者，讀者才會買單。 建立寫作流程：寫作也是需要流程的，選題、找素材、擬稿、成搞&amp;hellip;等，因人而異。 建立回饋系統：不管做任何事，回饋機制很重要，有回饋才有辦法改進，才能不斷的進步。  五個切入點寫出好文章  主題：對這世界要有點意見 一篇好的文章，主題很重要。作者認為我們應該『對這世界要有點意見』，多發表自己的觀點，用自己的思路去思考每件事。再來主題應該要可以覆蓋多數人群，打到大部分人的痛點，可以參考人生金字塔的五個階層。
題目：抓住眼球 好的題目可以讓讀者一眼看下去，就有『這就是我要找的』感覺。。這裡也可以參考剛剛提到的人生金字塔來擬定題目。 作者認為，好的標題包含三個因素：</description>
    </item>
    
    <item>
      <title>讀懂一本書 - 從讀書到說書</title>
      <link>https://ianjustin39.github.io/ianlife/read/understand-a-book/</link>
      <pubDate>Sun, 27 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/read/understand-a-book/</guid>
      <description>在開始讀書之後，讓我開啟了廣大的視野，但如何將書本的東西有效的吸收內化， 甚至可以將書本的內容有效的分享給別人，也是我現階段重要的課題， 如果能有效的『再傳遞』書本內的知識，那也就代表我真的掌握到這本書所想傳遞的精神，真正的『讀懂一本書』。
閱讀是『反脆弱』的武器  什麼是脆弱？就像玻璃杯從桌上掉落，就被摔碎一樣。 相反就是堅固？比方說換成鐵球，就不會與玻璃杯有一樣的下場。 若是再換換成乒乓球，那它掉到地上就會馬上彈起來。
在『反脆弱』一書中，作者認為脆弱的相反不是堅固而是反脆弱，如同乒乓球，不管怎樣用不良、負面的事件去影響，它不僅不會壞，反而會更強大、更優異。 在現實中，脆弱代表著怕變動、怕跳戰、面對突如其來的事件會遭遇損害；而堅固則是面對突如其來的事件，對它來說什麼都不會影響及改變；反脆弱則代表者勇於接受變動、挑戰，越多刺激，那自身能力就會越進步。
為什麼閱讀是反脆弱的武器呢？因為閱讀有兩個特點， 第一點是『主動性』：讀書是主動的學習，我們所讀一定是我們所需要的，這可以彌補自身知識的不足。 第二點是『針對性』：讀書所帶來的收穫因人而異，莎士比亞說『一千個讀者，就會有一千個哈姆雷特』。每個人會因為尋找符合自身個性化的領域吸收加強。
當掌握這兩點，遇到變動或是挑戰時，不會再像玻璃杯一樣一摔就破，而是有辦法去適應這些事件，讓自己越來越強大。
為知識鬆綁，會讀書也要會說書  為什麼會認為閱讀是痛苦的，因為我們認為閱讀的成效不如我們的預期。就像去下定決心要減肥，但發現鏡子裡的自己好像沒有瘦，得不到成就感，最後只好選擇放棄。
說書，是將書本的知識『再傳遞』，如果有辦法有效的講書，那也代表自己可以有效的掌握了這本書。要更有效的說書，在閱讀時我們必須不斷的問自己三個問題：
 我能不能準確把握這本書真正的含義，理解這本書？ 我能不能用自己的語言，清楚表達出這本書的真正含義？我的資訊效度和信度如何？ 我表達出來的內容能不能讓沒讀過這本書的人無障礙理解？我的語言是否通俗易懂，能夠被二次傳播？  每次閱讀帶著這三個問題，先說服自己，才有辦法傳遞給他人。 如同我們工作上網查資料，必須先篩選適合的資料，並過濾出有效的資訊，接著解讀、思考是否有符合我們需求的資訊、最後再將其驗證。
一般人的劃線重點 v.s. 說書人的劃線重點  究竟書中的名言佳句是不是重點，我們會在閱讀時畫下『我們認為』重要的句子，可能是某個偉人的名言佳句、又或者是讓我們有深刻體悟的一段話。 樊登認為這是非常關鍵的一個問題，所以總結了以下八個評判標準：
1. 當你感覺概念被清楚界定時 如同一開始提到反脆弱所舉的例子，玻璃杯、鐵球、乒乓球間所代表的差異性。
2. 當你感覺問題很嚴重時 如果自己都沒覺得嚴重，那怎麼說服他人。像之前讀到的『為了遇見40歲更好的自己』中有提到，我們總是想要做很多事，發現每件事都有做，但每件事都沒達成目標。 因為人類大腦無法同時判斷多組情報，因此三種左右是最適當的數量。過去我也曾經有這個煩惱，這本書所提到的這個面相讓我有深刻的體驗，也感受到這個問題的嚴重。
3. 當你感覺某種解釋令你很意外時 抽菸者要戒菸普羅大眾認為要靠毅力，直到樊登朋友因為一本『這書能讓你戒菸』，而成功戒菸，讓他對於戒菸的印象有個改變。 因為書中提到，如果淺意識內認為抽煙是好的，就算再有毅力都不會成功。 戒菸應該靠對吸菸的『認知』，要知道吸菸對於身體或是周遭的人所產生傷害，才有辦法從根本上戒除。
4. 當你看出遞進關係時 樊登提到他在講『世界觀』這本書時，無法略過第谷，因為第谷提供全套的觀測結果，所以克普勒提出第一定律及第二定律，接著牛頓則算出橢圓形上的週期運動，這就是一步步的遞進關係。
5. 當你看出轉折關係時，要留意轉折後的內容 閱讀到書中的轉捩點，或是讀到觀感上的反轉，這也是很重要的部分。
6. 不同面向彰顯書籍內的價值 有的書結構是遞進；有的則是先提出主題，再用不同面向的去驗證這個主題。我認為我看過的書中『原子習慣』是遞進，而無限賽局則是『提出主題』。
『原子習慣』一書中，先定義習慣的對我們的影響多大，在從頭開始述說我們要怎麼去建立一個原子習慣。 『無限賽局』則是先定義無限以及有限定義出來，再經由幾個面向去解釋驗證無限思維的重要。
7. 閱讀受到心靈衝擊 在『無限賽局』一書中提到，無限思維與有限思維的差異讓我有深刻的體會。
8. 書中的奇聞趣事，增添說書的趣味性 記下一些書中提到有趣的故事，可以在說書時分享，讓過程更有趣。
讀後心得  在開始閱讀之後，時不時會與幾個朋友聚再一起分享閱讀的書籍，雖然每次都有寫下書本摘要及心得，但總感覺無法有效的將書中的知識做傳遞。 最初選這本書的原因只是希望自己可以真正的將書本內的知識吸收，並有效的轉換成文字或是言語分享給其他人，但讀完之後給我的啟發已經遠超過當初的期待。 從為什麼要閱讀、如何讀懂一本書、如何抓取書中的重點知識、說書其實是再創作、運用心智圖說書&amp;hellip;等等，對我來說都非常的有幫助。
我滿喜歡書中提到的一點『理解的池子有多大，就能讀懂多難的書』。如果連三角函數都不會，怎麼去學微積分，唯有不段的充實自己，才有更多的可能性。</description>
    </item>
    
    <item>
      <title>無視礦工，以太坊的倫敦硬分叉</title>
      <link>https://ianjustin39.github.io/ianlife/blog/technology/blockchain/blockchain/ethereum-london-hard-fork/</link>
      <pubDate>Wed, 16 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/blog/technology/blockchain/blockchain/ethereum-london-hard-fork/</guid>
      <description>前言  現今以太坊的手續費過於昂貴，交易者需要付出高額的手續費才可以完成交易。 這次的 Ethereum London Hard Fork （倫敦硬分叉）所做的更新，包含了 EIP-1559、EIP-3198、EIP-3238 三個提案， 其中 EIP-1559 也是這次比較備受關注的部分。
EIP 是什麼？  EIP(Ethereum Improvement Proposals)，是為以太坊指定潛在新功能或流程的標準，包含提議更改的技術規範。通過 EIP 流程討論和開發以太坊的網絡升級和應用標準。
提案一： EIP-1559（區塊鏈交易費用模型）  EIP-1559 是對用戶在以太坊網絡上支付 gas 費用方式的更改。（由於現在以太坊交易手續費過高，降低對用戶的吸引力）
 以往：礦工可以賺的收入「挖礦獎勵」跟「 100% Gas fee 」 EIP 1559 ： gas fee 分為基礎費（base fee）和小費兩種，給礦工的是「小費」； base fee 的 50% 會直接銷毀。  EIP-1559 也導入目標塊容量機制，每個區塊的基本費用根據網絡需求而變化。如果一個區塊的交易量超過 50%，則基本費用將增加，低於 50% 的話基本費則會下降。 而基本費可能會隨著交易加入 block 時發生改變，可以先將 price 設定成願意支付的上限，最後沒用到的部分會退還。
這個提案重點在於基本費會被銷毀，並不會所有的 gas fee 都讓礦工拿走。而也藉由『銷毀』機制，讓以太幣的供應量下降，避免通貨膨脹。
交易格式的差異 以下部分段程式碼是從 EIP-1559 擷取。
新交易格式內的 base_fee_per_gas ＆ priority_fee_per_gas 取代了以往的 Legacy Ethereum transactions 的 gas_price。 但 EIP-1559 可以相容 Legacy Ethereum transactions 的格式。 雖然現有的交易格式仍然有效且也被包含在 block 中，不過 Legacy transactions 沒辦法享有新的 pricing system 所帶來的優點。</description>
    </item>
    
    <item>
      <title>無限賽局 - 『永續』還是『取勝』？</title>
      <link>https://ianjustin39.github.io/ianlife/read/game-the-infinite-game/</link>
      <pubDate>Sat, 15 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/read/game-the-infinite-game/</guid>
      <description>
沒有開始、中場以及結束的賽局  想想從小到大，我們經歷了許多賽局，像是體育競賽，有已知的玩家，既定的規則。在達成目標，也就是誰的比分先到標準，該隊伍就會獲勝，賽局就會結束。 相較於競技比賽的『有限賽局』。『無限賽局』中並沒有時間限制、沒有終點線、沒有真正的結束，像是商場上會不斷的有新玩家加入，沒有既定的規則，大家會依照自己的方式衍生出商業模式，試著一直存活在這場賽局內。
從微軟與蘋果間的戰爭看待商業賽局  微軟本來的願景，是為了提高生產力，幫助地球每個人到組織，可以貢獻更多，成就更大。但到了近幾年，公司的目標逐漸轉向『打贏競爭者』，也就是打贏蘋果。 作者曾經受邀在微軟以及蘋果的教育高峰論壇上演講。在微軟的論壇中，多數的講者都會提到如何打敗蘋果；而在蘋果的論壇內，講者都花時間在討論蘋果如何幫助老師教學、幫助學生學習。
打敗蘋果事現在微軟的目標，所以微軟的產品都以『性能需要比蘋果強』為出發點思考；反之蘋果則是思考如何達到公司願景，創造更好的產品來滿足大眾的需求，並且可以不段的創新突破，這樣的信念也進而改變了市場的結構。
無限思維的五個關鍵  如何從有限思維的框架中跳脫出去，進而有無限思維呢？作者提供了五個關鍵給我們
崇高的信念 崇高的信念是對一個尚不存在的未來懷抱具體的願景；這個未來令人嚮往到人們願意犧牲小我，來實現這個願景。  『隨時隨地以最低的價格來服務美國廣大的勞工』，這是美國零售業沃爾瑪的企業願景。其創辦人沃爾頓秉持著這個信念經營，在經濟大蕭條時成為了最富有的人之一。 但就算這樣，沃爾瑪也有背離信念的時候。接任執行長杜克上任後，將公司目標轉向利潤、成長以及市場地位，服務的對象以股東為首，不在是美國勞工。這也造就了後續沃爾瑪的各種負面新聞。直到明倫接任杜克之後，才重拾沃爾瑪的信念，將公司帶回無限賽局內。
信念不像目標，達成就結束，而是會一直持續下去。若公司的不在以信念為核心推廣業務，反而只在乎獲利、報酬，長久下來會脫離原本的軌道，也無法進步。
彼此信任的團隊 領導者要負責的不是結果，領導者要負責的是要對結果負責的人們。  組織文化、環境關係到一個團隊的是否可以高效率的執行作業。 許多公司現在提倡組織扁平，每個員工都可以為了公司、產品提出自己的見解，讓資訊流通暢行無阻。 而領導者的責任就是維持這個組織的文化，提升成員對團隊的信任程度，讓員工發揮最佳的表現。
『有限思維』的領導者關注『結果』、『績效』，想著如何壓榨員工，讓他們達到自己預期的成果； 『無限思維』的領導者則是關注團隊的『環境』、解決問題的『過程』，遇到問題時大家是否可以適時的提出自己的意見，並一起解決眼前的問題。
可敬的對手 傳統思維讓我們採取要獲勝的態度，敬畏對手的思維則啟發我們採取改進的態度  『成為第一』、『打敗對手』內心總是想著如何讓對手退出賽局，傳統的思維讓我們侷限在只能『獲勝』的層次。 或許仔細思考，可以發現因為對手所擅長的事自己並不擅長，但我們卻不願意面對，轉而將精神放在如何擊敗他的上面？ 擁有『無限思維』的人為認為，可敬的對手指出了自身的不足，我們可以藉由向對方學習，不斷的提升自己，讓自己不斷的朝『崇高的信念』邁進。
『有限思維』的人關注『結果』，想著如何才可以打敗對手； 『無限思維』的人關注改變的『過程』，改變讓自己更接近『崇高的信念』。
攸關存亡的應變 攸關存亡的應變是為了更有效地推動信念，即使這麼做會顛覆現有的商業模式。  以往的商業模式可以賺大錢，但套用在現今或許不在實用，可以從柯達這間公司來思考。
『像鉛筆一樣簡單。你俺快門，剩下的交給我們。』這是柯達的廣告詞。 柯達的底片佔了公司大部分營收，而第一台數位相機也是柯達發明，但為什麼柯達最後還是敗在數位相機？
柯達的領導者認為，數位相機這項產品，與自家的底片有衝突，如果就這樣發表出去，可能會影響到公司的營收。 最後領導者認為底片才是賺錢的來源，而數位相機會讓賣出的底片變少，所以選擇不發表這項產品。 十年後 Nikon 發表第一台數位相機，而柯達到最後也退出了這場賽局。
『有限思維』的人關注『短期獲利』，只想著怎麼樣才可以賺錢，而忽略了自身的信念； 『無限思維』的人關注『推動信念』，攸關存亡的應變為了更推動『崇高的信念』，即使推翻現有的商業模式。
領導的勇氣 正值不只是做對的事，正直是在大眾抗議或醜聞發生之前就採取行動。 當領導這知道公司明明在做不道德的事，卻等輿論爆發之後才採取行動，這不是正直，這叫損害控制。  2014 年，美國最大的連鎖藥局 CVS 宣布停售香煙及菸草，這項決定並沒有人去要求 CVS ，也並非任何負面消息，縱使這項決定會使他們每年損失二十億美元。 CVS 的領導者用『信念』來引導公司業務，而這項決定也讓有使命感的公司去跟他們合作，開啟了 CVS 在保健食品這塊領域的商機，也提升了公司的形象。 反觀競爭對手，只高喊帶給世人健康的信念，而沒有勇氣做出改變的決定。
限時的無限賽局  或許『信念』才是『無限思維』根本，蘋果的信念是創新，微軟的信念是激發大家的生產力，『崇高的信念』造就了這些偉大的公司。 當信念轉變成利益導向，如同微軟不在思考怎麼讓大家發揮價值，而把目標轉向打贏蘋果，此時陷入有限思維的微軟，如同丟掉武器赤手空拳的來對抗競爭者，對於蘋果的競爭力也不在像以前那麼高。
人生本是一場『無限賽局』，但我們僅擁有有限的時間，我們要用『無限思維』去看待這場『限時的賽局』。崇高的信念可以讓思維跳脫輸贏，可以犯錯、可以推翻現況，就是為了更接近人生的信念；擁有可敬的對手讓我們不在只在乎表面的輸贏，而是成為互相檢視的導師，推動自己不斷的向前邁進。當我們不在以『我』為中心來思考任何事，而是將眼光放遠，以信念來引導我們的方向，勢必可以創造屬於自己的價值，並影響更多的人。
🔅 原子習慣：一旦你發現『時間』才是最寶貴的貨幣，你會徹底改變你的生活風格和習慣。  SlideShare   顯示簡報   Game the infinite game  from Ian Tsai  </description>
    </item>
    
    <item>
      <title>超速學習 - 『學習』從來不是一件輕鬆的事</title>
      <link>https://ianjustin39.github.io/ianlife/read/ultralearning/</link>
      <pubDate>Sun, 21 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/read/ultralearning/</guid>
      <description>如何成為超速學習者？  超速學習並非千篇一律的方法，每個人的學習計畫都是獨特的，而要到達的精通程度所需的方法也不同。這本書中整理出了九個普遍的法則基礎，並稱這套方法為超速學習。
後設學習、專心致志、直接學習、反覆練習、提取記憶、意見回饋、保留記憶、培養直覺、勇於實驗
建立學習地圖  超速學習的第一步為『後設學習』，後設學習在這本書中指的是學習關於學習這件事。比方說，只會英語者以及會西班牙語加英語的雙語者同時學法語課。後續追中顯示，雙語者表現會優於單語者。
為什麼？因為西班牙語以及法語都是羅馬語系，因此對雙語者來說是一個優勢。但其原因不只是這樣！會多種語言者可以藉由比較兩種或以上語言特中，開發出不同語言學習的策略能力。也就是所謂的『後設語言覺識』。
而要畫出學習地圖，則要先問自己『為什麼、做什麼、怎麼做』，進而了解自己的學習目標以及方法。
真正的學習，其實是在直接做你想變擅長的事時才會發生  回想以前考高中大學時常常聽到一句話：『若你覺得現在唸書是痛苦的，那代表你做對了，請你堅持下去。』，在我的認知裡，直接學習一項技能並不會太舒服，甚至很痛苦，例如想學一種語言，並非直接看文法、背單字或是與人對話，而是透過各種有趣的應用軟體，讓自己有種『我好像學到東西』的感覺。而 真正的學習，其實是在直接做你想變擅長的事時才會發生。 當真的要學習語言，應該思考如何做直接的可以學習到這項技能，比方說上線上真人課程與外國人溝通、每天閱讀英文報章雜誌學習新字彙&amp;hellip;等。
在被迎面痛擊之前，每個人都有自己的一套計畫。  學習過程中，取得回饋很重要，回饋是可以評估學習成效的重要方式之一。但不見得回饋越多越好，關鍵在於得到回饋的類型。當回饋提供的是指引學習方向有用的資訊，那就會有好的效果。若是給一個個體的評價，例如：『你好棒！』或是『你好懶墮&amp;hellip;』，這並非是對學習本身的回饋，通常會對學習有負面影響。
而回饋的不當解讀或無法給予有用的資訊，也會造成反效果。超速學習者必須留意兩種可能性：
 對並未提供能帶來有用資訊的回饋反應過度。超速學習者必須對回饋敏感，並過濾。 如果運用不當，回饋對行動力也會有影響。過度負面會降低行動力，過度正面會阻礙進步。  勇於實驗，往舒適圈外探索  開始一項新技能時，通常只要照著比自己厲害的人去做就夠了。但隨著越學越多，只是遵循榜樣通常不再足夠，必須自己去實驗，找到屬於自己的道路。比方說一個程式設計師，一開始學寫程式時，通常都是上網找尋範本。但等到累積一定的知識量後，就不用在複製別人的範本，而是自行架設一個網站，可以藉由自行架設網站的過程中，知道哪些部分的能力還需要加強。
費曼技巧  書中第八個法則『培養直覺』中提到了費曼技巧，讓我想起為什麼想寫文章，一方面是想要紀錄自己學了什麼，另一方面是想如果是別人看我的文章，可以理解這個東西到什麼程度、要如何將我所理解的知識傳遞給他人，若無法順利傳遞知識，代表我對於正在學習的項目還不是很了解。
 在一張紙的最上方，寫下你想了解的觀念或問題。 在下方空間解釋那個想法，彷彿你必須傳授他人。  若是觀念，先問自己，要如何把這個觀念傳給從未聽過的人 若是問題，就說明該如何解答；重要的事，要說明你為何認為解題步驟是合理的。   當你卡住了，就代表你的理解無法提供清楚的解答，請回去找書、筆記、老師、或是參考資料，直到找出答案為止。  可以應用在三個地方：
 你完全不了解的事物。 你似乎無法解決的問題。 為了擴展直覺。  讀後心得  超速學習在這本書中，給了滿多真實範例及方法。但他絕對不是教你如何輕鬆學習，因為超速學習的定義為『一種獲取技能與知識的策略，兼具自主性與高強度。』而在書中也點出了一些我在學習時產生的盲點，如『直接學習』。就像上面講的，往往學習新事物都是痛苦的，所以都想要用輕鬆的方式去達成學習的成果，但都忽略了最直接的學習，可以最快速了解內容，雖然過程不舒服，但累積下來的成果也將非常可觀。
閱讀筆記  若想參考閱讀筆記，可以點 這裡 參考</description>
    </item>
    
    <item>
      <title>快速排序 - Quick Sort</title>
      <link>https://ianjustin39.github.io/ianlife/algorithms/quick-sort/</link>
      <pubDate>Wed, 17 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/algorithms/quick-sort/</guid>
      <description></description>
    </item>
    
    <item>
      <title>合併排序 - Merge Sort</title>
      <link>https://ianjustin39.github.io/ianlife/algorithms/merge-sort/</link>
      <pubDate>Tue, 16 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/algorithms/merge-sort/</guid>
      <description></description>
    </item>
    
    <item>
      <title>泡沫排序 - Bubble Sort</title>
      <link>https://ianjustin39.github.io/ianlife/algorithms/bubble-sort/</link>
      <pubDate>Mon, 15 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/algorithms/bubble-sort/</guid>
      <description></description>
    </item>
    
    <item>
      <title>複身犯 - 寫出你的名字，你是誰？</title>
      <link>https://ianjustin39.github.io/ianlife/movie/plurality/</link>
      <pubDate>Sun, 14 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/movie/plurality/</guid>
      <description>上次看電影是2019年的事（沒看天能，有理由不當低能🤣），而上次看國片更不知何時了，對於國片的記憶還停留在『大尾鱸鰻』、『總鋪師』等等賀歲片，這次剛好朋友介紹而看這部電影，起初以為是類似於人格分裂的犯罪電影，想不到劇情比我想的還要豐富，有點刷新了我對於國片既定的印象。雖然有部分沒有解釋的很到位，但對於我來說，看電影就是放鬆心情，不要太過於糾結🤣🤣🤣。
以下心得可能有點雷，還沒看過的就先跳出囉！！
人格的撕扯，我不是我。  『攔截記憶碼』是我對於這類電影的一個印象，但這片一次注入五個人格到單一個體的精神裡，是給演員的一大考驗。個人覺得楊祐寧把這五個人都詮釋的不錯，畢竟一次演兩個人就已經不是一件簡單的事了，更何況是五個人。而在這五個人存在於意識裡的空間，是與現實相同的實驗室，表示就算你們逃出了現實的實驗室，在意識裡面還是被關起來的。如果某一個人格想要驅動 193 的身體，就需要找到一個紅門，這個紅門，象徵著 193 與女兒講的『怪角鹿』的故事，那隻鹿為了面對自己而穿過的紅門。
張榕容飾演的科學家沈宜玲，竭盡自己的所學，為了小孩，不放棄所有可能找到他的線索，體現出一個母親，可以為自己的孩子付出一切。故事的最後，意外的反轉，193 並不是許明哲，而真的許明哲，為了奪取身體而模仿甚至策劃抹殺所有人的意識，一種『我不是我，那我是誰』的感覺。
整部下來印象最深刻的一句話還是公車司機邱俊生的：我只是想看我阿嬤啊
觀後的省思  世界友善對待先天有缺陷的人並不友善 想起以前學生時代，大家對於一些行為怪異或是身心有缺陷的人了，往往都給予不友善的態度甚至會霸凌他們。大家普遍認為他們是怪人，給與異樣眼光，對於這些人來說，這個世界有的甚至父母，都不會友善的對待自己。片中許明哲以及 193（意識載體）分別用不同的方法，去對待這些人。但許明哲這種極端的行為，也許演出很多人內心不敢表現出的想法，而 193 則是父母對待自己子女愛的體現。不禁讓人反思，是不是因為我們而造就了這個不友善的世界？
被『正義』包裝的『惡』 片尾王警官說：『我們沒辦法知道怪物的腦中想什麼，或許殺了他們，反而對他們比較好。』這句話就跟許明哲對沈宜玲（張榕容）講的話一樣：『這世界對他們並不友善，所以殺了他們。對他們比較好。』。往往有些『惡意』的外層包裝了『正義』，社會大眾就會覺的是合理的事，但是否只要是『正義』就是絕對的正確呢？
不管這個世界怎麼看你，你都要相信你自己。 193 對女兒說：『不管這個世界怎麼看你，你都要相信你自己。』
現在的人大多數在意『別人怎麼看我』，但我們是想要活出『我夢想中的自己』，還是『別人眼中的自己』。適度的在意並把意見化為養分是必要的，但應該要過濾，不是照單全收。
最後，你們有沒有看我阿嬤啊</description>
    </item>
    
    <item>
      <title>在 Hugo Blog 中加上 Algolia 文章搜索工具</title>
      <link>https://ianjustin39.github.io/ianlife/build-blog/hugo-and-algolia/</link>
      <pubDate>Sat, 13 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/build-blog/hugo-and-algolia/</guid>
      <description>隨著文章越來越多，要找到以前寫的文章就越來越麻煩，所以就一直想尋找站內搜索的功能使用。之前有試用 google 的站內搜索功能，但總覺得整體不是很好看，也就沒有繼續使用。直到最近看到 Algolia ，可建立文章的索引，將資料上傳到 Algolia，再藉由串接 API 就可以完成搜索功能。
接下來就開始建立站內搜索功能吧。
註冊 Algolia  第一步就是要到 Algolia 註冊帳號，登入後會要求輸入一個 index（等等要用到這個 index），然後會以這個 index 建立一個 app ，接著選擇存取的國家（我是選日本），完成之後會有這個畫面。
然後點選左邊的 API Keys，這邊有等等設定需要使用的參數，可以先將他們記下來。
註：Algolia 有分幾個付費等級，現在有 15 天試用期，不過因為 blog 只需要簡單的搜索文章的功能，這裡目前是使用免費版，若要更進階的功能可以自行研究看看。
hugo 生成索引文件  1. 修改 config.toml 修改./config.toml設定好需要的參數。
[outputs] home = [&amp;#34;HTML&amp;#34;, &amp;#34;RSS&amp;#34;, &amp;#34;Algolia&amp;#34;] [outputFormats.Algolia] baseName = &amp;#34;algolia&amp;#34; isPlainText = true mediaType = &amp;#34;application/json&amp;#34; notAlternative = true [params.algolia] appId = &amp;#34;剛剛看到的 ID&amp;#34; indexName = &amp;#34;一開始輸入的 index&amp;#34; searchOnlyKey = &amp;#34;剛剛看到的 Search Only Key&amp;#34; vars = [&amp;#34;title&amp;#34;, &amp;#34;summary&amp;#34;, &amp;#34;date&amp;#34;, &amp;#34;publishdate&amp;#34;, &amp;#34;expirydate&amp;#34;, &amp;#34;permalink&amp;#34;] params = [&amp;#34;categories&amp;#34;, &amp;#34;tags&amp;#34;, &amp;#34;series&amp;#34;]</description>
    </item>
    
    <item>
      <title>咖啡的價值 - 是買咖啡還是買時間？</title>
      <link>https://ianjustin39.github.io/ianlife/life/a-cup-of-coffee/</link>
      <pubDate>Fri, 12 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/life/a-cup-of-coffee/</guid>
      <description>到咖啡廳唸書？  很多人喜歡到咖啡廳看書，曾經的我覺得，為何要花錢去咖啡廳看書？自制力高一點在家看不就好了，何必要多花一筆錢？那到底有沒有必要去咖啡廳唸書？
一杯咖啡的價值  每到週末，我就會想著：『難得的假日，休息一下再來做事好了！』，然後就晚上了。是自制力不足，還是目標不夠明確所以才導致這個結果呢？
原子習慣一書中提到，『改變習慣的四大法則之一：讓習慣淺而易見』，反之則是讓壞習慣視而不見。那這跟在家看書有什麼關係？
想想自己房間裡的環境，看到床就想睡一下、看到電動就想玩一下、走到客廳看到電視就想看一會兒&amp;hellip;諸如此類，當我們想要在這充滿誘惑的環境做一些不屬於這個環境的事情，想必會有一定的難度，而我們的時間往往就這樣被消磨掉了。一個週末、兩個週末&amp;hellip;這樣的時間累計起來，其實也是滿可觀的。
而我開始對『一杯咖啡的價值』開始有了不一樣的想法。他是單純菜單上的 60/100 元的『飲料』，還是他可以想成，你用這樣的價錢，控制了你一天的『時間』？
資產與負債  一杯咖啡，怎麼會講到資產與負債？我認為這兩件事的觀念有點相似。現在常聽到人問，『什麼是資產？你的房子是不是？你的車子是不是？』，而答案通常會是『房子那來出租，就會是資產；車子拿來載客人，也是資產。』
那我買一杯咖啡，到底是投資還是消費？
一杯咖啡換一天的時間  高爾基：『時間是最公平合理的，它從不多給誰一分。』  老天給我們最公平的東西就是——時間，每個人都有，無論是貧賤、富貴，每個人都是一樣的，而時間是公平的，我們每個人能擁有它，但因為使用它的方式不同，導致在『相同』的時間內，沒有相同的結果。
而現在，我用一杯咖啡，換到一個沒有誘惑的環境、換來一天的時間，這件事讓我不再認為『到咖啡廳唸書』是個浪費錢的事情，反而覺得是非常值得的『投資』。</description>
    </item>
    
    <item>
      <title>字典樹 - Trie</title>
      <link>https://ianjustin39.github.io/ianlife/algorithms/tries/</link>
      <pubDate>Tue, 09 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/algorithms/tries/</guid>
      <description></description>
    </item>
    
    <item>
      <title>二分搜尋演算法 (Binary search algorithm) - 終極密碼</title>
      <link>https://ianjustin39.github.io/ianlife/algorithms/binary-search/</link>
      <pubDate>Sun, 07 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/algorithms/binary-search/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/binary-search/&#34; target=&#34;_blank&#34;&gt;圖片來源&lt;/a&gt;
&lt;br&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>為了遇見40歲更好的自己</title>
      <link>https://ianjustin39.github.io/ianlife/read/40-years-old/</link>
      <pubDate>Sun, 21 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/read/40-years-old/</guid>
      <description>讀後心得 40歲是夾在上一代及下一代中間的一個世代，為了讓自己過得更好，需要學會捨棄一些事物。但往往要捨棄時，又會有些捨不得。就像要整理自己的衣櫃時，拿出很多衣服可能一年內根本沒拿出來穿過，但卻捨不得丟掉，又把他放回衣櫃裡佔去了衣櫃的空間。而哪些東西是該捨棄，而為什麼要捨棄，捨棄之後可以達到什麼效果，這本書基本上都有提到。書中有5個大章節、43個小章節，我挑幾個感受比較深的項目拿來舉例。
1. 『勇於捨棄』，提升人生的品質 我還年輕，我全身都很健康；這個我以前就是這樣做，絕對沒問題。這些『自信』、『堅持』大家一定都有過。但隨著時間的推移，我們會變老，時代會進步。需要不段的定期檢討、不段的求新求變，才不會被社會淘汰。華特·迪士尼說過：『迪士尼永遠不會完工，維持現狀等於是一種退步。』
2. 習慣改變，行動自然改變 一開始有提到整理衣櫃。根據調查顯示，女性的衣櫃內有70%的衣服是沒再穿的，只有30%的衣服是平常有再穿的。作者建議把這70%的衣服丟掉，留下真正需要的30%。而依照人的習慣，還是會把這70%補滿。但補滿以後的衣櫃，裡面都是會穿出去的衣服。套用到人身上也一樣，應該適時的檢視並捨棄自己不需要的東西，補充新事物給自己。
3. 透過『選擇與集中』，提升工作的成果 在樹立目標的時候，我們往往會想要達成多件事情。例如：每個月要讀完一本書、英文要考到多益900分、要養成每天運動的習慣、要學習股票投資&amp;hellip;等等。但之後會發現每件事都有做，但都沒有達到目標。研究顯示，人類大腦無法同時判斷多組情報，因此三種左右是最適當的數量。所以我們可以把要執行的事情縮至三項，將其他事項暫時捨去，才可以專心的去完成每件事。此外，也要定期的檢視自己的執行項目是否有需要或是可更新成更好的方法，並定期的記錄下來。
4. 調整『時間分配』，改變成長速度 『我今天要看完一個線上課程，但上完班好累喔，休息一下再看好了！』，相信大家都有這個經驗，但休息一下之後，就準備洗澡睡覺了。如何避免這種情況發生呢？書裡建議我們，事先『算好』時間。也就是將你要做的是用時間去切分好，如下圖：
應先固定好時間，再決定做什麼事。但通常我們無法『完美的』執行我們的計劃，有時可能會有突發狀況發生，所以也必須捨棄『行程必須百分之百完成』的義務感，並不是沒做到就是失敗，而是要有些彈性。
5. 和『真正重要的人』建立人際關係 到新公司就減少與前公司聚餐的次數，因為『如果不跟現在公司的同事打好關係，就無法創造成果。』。
並不是到了新公司就要捨棄舊同事，而是現在是與新同事共事，要與他們一起創造成果。但如何與同事來往更加緊密？書中提到『讓溝通戲劇性改變之三種應可棄的東西』
 為了得到旁人的信賴，請停止『責人』：在遇到問題時，應該先思考自己可以付出什麼，而非先找戰犯。 若想討人喜歡，請捨棄『想討人喜歡的念頭』：應該適時的表達意見，而不是一直考慮是否會被對方討厭。 想要聽見對方的真心話，請捨棄『先入為主的觀念』：產品好不好用，是客戶決定。我們應該思考『這件事由誰判定？』而非自己先覺得對方怎想。   『改變行為一定可以改變結果』，書中讓我們思考什麼該東西是現在應該捨去的。例如：過度的自信、自我堅持、達到目標途中不需要的東西&amp;hellip;等等。專心對待眼前最重要的事物，才有辦法完成目標。這本書雖然有些觀點個人是稍微不認同，不過整體來說是不錯的，可以看看！！
閱讀筆記 若想參考閱讀筆記，可以點 這裡 參考</description>
    </item>
    
    <item>
      <title>原子習慣 - 細微改變帶來巨大成就</title>
      <link>https://ianjustin39.github.io/ianlife/read/atom-habits/</link>
      <pubDate>Sat, 23 Jan 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/read/atom-habits/</guid>
      <description>讀後心得 如果每天進步百分之一，持續一年你會進步37倍； 每天退步百分之一，一年後就會弱化到趨近於零，時間會放大成功與失敗之間的差距。 當我們想著要改變的時候，往往想著馬上就可以看到成果，但都忽略一些細微的改變。想想每年年初都訂立一些目標，我 TOEIC 要考 950 以上、我今年要變成巨巨&amp;hellip;等等。但到了年底發現，我今年跟去年好像一樣都沒變，怎麼會這樣？
決定成功與失敗的，並非目標，而是系統。
例如：Ａ跟Ｂ都想要有六塊腹肌，但一年後，Ａ成功的練出了腹肌，Ｂ卻跟原本的一樣。差異在哪？
Ａ一周至少上六天健身房，且有做飲食控管並記錄每天的身體數值、飲食及訓練項目。Ｂ一週也上六天健身房，但卻沒有控制飲食以及紀錄。兩個人的目標相同，但執行方式（系統）卻不一樣，所以造就了不同的結果。
可以發現，雖然定了目標，但系統執行的方向不對，所呈現的結果也不一樣。
我們往往把注意力過於放在目標上，忽略了如何執行這件事。而對於想要改變習慣，卻因為習慣過於難執行，又或是生活讓我們只能安於現狀，最後只能回歸原樣。
提示 &amp;lt;&amp;gt; 讓提示顯而易見 渴望 &amp;lt;&amp;gt; 讓習慣有吸引力 回應 &amp;lt;&amp;gt; 讓行動輕而易舉 獎賞 &amp;lt;&amp;gt; 讓獎賞令人滿足 這是書中提到養成習慣的四種方法，簡單用這四個法則來延續六塊肌例子：
  讓提示顯而易見
為了養成健身的習慣，將健身手套放在書桌上，看到手套就知道該去健身房了。
  讓習慣有吸引力
去健身房只是為了健身？No！當然是為了看健身妹子跟巨巨的肌肉拉，所以會為了這件事所以去健身房。
  讓行動輕而易舉
選一間離家走路三分鐘的健身房，這樣就算下雨也只需要撐個傘就可以到了。
  讓獎賞令人滿足
每天持續記錄自己的體態，看到改變而帶來的成就感。（或是因為去健身房脫單）
  而壞習慣就反向而行，這樣就可以比較有效的建立自己的習慣。
看完這本書後，練習了一下覺得其實滿受用的。書中也有舉許多實例，讓法則比較淺顯易懂。滿值得入手的一本好書，不愧是暢銷前幾名。
閱讀筆記 因為是心得所以不想打太多筆記類的東西，若想看閱讀筆記，可以點 這裡 參考</description>
    </item>
    
    <item>
      <title>策略模式 | Strategy Pattern</title>
      <link>https://ianjustin39.github.io/ianlife/design-pattern/strategy-pattern/</link>
      <pubDate>Tue, 06 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/design-pattern/strategy-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    定義一系列演算法，並將其封裝起來，使他們可以相互替換，演算法的變換不影響使用。</description>
    </item>
    
    <item>
      <title>觀察者模式 | Observer Pattern</title>
      <link>https://ianjustin39.github.io/ianlife/design-pattern/observer-pattern/</link>
      <pubDate>Mon, 05 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/design-pattern/observer-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    多個物件之間存在著一對多的依賴關係，當一個物件發生改變時，所有跟他有關的物件都會被通知且更新。</description>
    </item>
    
    <item>
      <title>備忘錄模式 | Memento Pattern</title>
      <link>https://ianjustin39.github.io/ianlife/design-pattern/memento-pattern/</link>
      <pubDate>Sun, 04 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/design-pattern/memento-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    在不破壞封裝的前提下，儲存一個物件的某個狀態，以便於需要的時候將物件恢復到原先儲存的狀態。</description>
    </item>
    
    <item>
      <title>狀態模式 | State Pattern</title>
      <link>https://ianjustin39.github.io/ianlife/design-pattern/state-pattern/</link>
      <pubDate>Sat, 03 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/design-pattern/state-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    有狀態的物件，把複雜的邏輯判斷分配到不同的狀態物件中，允許狀態物件在其內部狀態發生改變時改變行為。</description>
    </item>
    
    <item>
      <title>中介者模式 | Mediator Pattern</title>
      <link>https://ianjustin39.github.io/ianlife/design-pattern/mediator-pattern/</link>
      <pubDate>Fri, 02 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/design-pattern/mediator-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    定義一個 Mediator 物件用來封裝一組物件的互動方式。Mediator 藉由避免物件間相互直接的引用，從而降低它們之間的耦合程度，並且可以讓我們獨立地改變這些物件間的互動方式。</description>
    </item>
    
    <item>
      <title>迭代器模式 | Iterator Pattern</title>
      <link>https://ianjustin39.github.io/ianlife/design-pattern/iterator-pattern/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/design-pattern/iterator-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    提供一種方法可以順序性讀取一個集合物件中的各個元素，而又不會暴露該物件的內部表示。</description>
    </item>
    
    <item>
      <title>命令模式 | Command Pattern</title>
      <link>https://ianjustin39.github.io/ianlife/design-pattern/command-pattern/</link>
      <pubDate>Wed, 30 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/design-pattern/command-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義   The Command Pattern encapsulates a request as an object, thereby letting you parameterize other objects with different requests, queue or log requests, and support undoable operations.</description>
    </item>
    
    <item>
      <title>責任鏈模式 | Chain of Responsibility Pattern</title>
      <link>https://ianjustin39.github.io/ianlife/design-pattern/chain-of-responsibility/</link>
      <pubDate>Tue, 29 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/design-pattern/chain-of-responsibility/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    將多個物件連成一條鏈，沿著這條鏈傳遞至每一個物件並處理請求。</description>
    </item>
    
    <item>
      <title>代理模式 | Proxy Pattern</title>
      <link>https://ianjustin39.github.io/ianlife/design-pattern/proxy-pattern/</link>
      <pubDate>Mon, 28 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/design-pattern/proxy-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    爲其他物件提供一種代理以控制對這個物件的訪問。</description>
    </item>
    
    <item>
      <title>享元模式 | Flyweight Pattern</title>
      <link>https://ianjustin39.github.io/ianlife/design-pattern/flyweight-pattern/</link>
      <pubDate>Sun, 27 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/design-pattern/flyweight-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    運用共享技術有效地支持大量細粒度的物件。</description>
    </item>
    
    <item>
      <title>外觀模式 | Facade Pattern</title>
      <link>https://ianjustin39.github.io/ianlife/design-pattern/facede-pattern/</link>
      <pubDate>Sat, 26 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/design-pattern/facede-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    為子系統中的一組接口提供一個統一的高層接口，使得子系統更容易使用。</description>
    </item>
    
    <item>
      <title>裝飾者模式 | Decorator Pattern</title>
      <link>https://ianjustin39.github.io/ianlife/design-pattern/decorator-pattern/</link>
      <pubDate>Fri, 25 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/design-pattern/decorator-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    裝飾模式動態將責任附加在物件上，若要擴展功能上，裝飾者提供比繼承更有彈性的替代方案。</description>
    </item>
    
    <item>
      <title>组合模式 | Composite Pattern</title>
      <link>https://ianjustin39.github.io/ianlife/design-pattern/composite-pattern/</link>
      <pubDate>Thu, 24 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/design-pattern/composite-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    物件以樹狀結構組合，做為表現出整體-部分的階層關係。</description>
    </item>
    
    <item>
      <title>橋接模式 | Bridge Pattern</title>
      <link>https://ianjustin39.github.io/ianlife/design-pattern/bridge-pattern/</link>
      <pubDate>Wed, 23 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/design-pattern/bridge-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    將抽象部分與實現部分分離，使它們都可以獨立的變化。</description>
    </item>
    
    <item>
      <title>適配器模式 | Adapter Pattern</title>
      <link>https://ianjustin39.github.io/ianlife/design-pattern/adapter-pattern/</link>
      <pubDate>Tue, 22 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/design-pattern/adapter-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    The Adapter Pattern converts the interface of a class into another interface the clients expect.</description>
    </item>
    
    <item>
      <title>原型模式 | Prototype Pattern</title>
      <link>https://ianjustin39.github.io/ianlife/design-pattern/prototype-pattern/</link>
      <pubDate>Mon, 21 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/design-pattern/prototype-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    用原型例項指定建立物件的種類，並且通過拷貝這些原型建立新的物件。</description>
    </item>
    
    <item>
      <title>生成器模式 | Builder Pattern</title>
      <link>https://ianjustin39.github.io/ianlife/design-pattern/builder-pattern/</link>
      <pubDate>Sun, 20 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/design-pattern/builder-pattern/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    把一個複雜物件的建構與樣貌分離，如此相同的建構過程可以產生不同樣貌的物件</description>
    </item>
    
    <item>
      <title>抽象工廠模式 | Abstract Factory Pattern</title>
      <link>https://ianjustin39.github.io/ianlife/design-pattern/abstract-factory-pattern/</link>
      <pubDate>Sat, 19 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/design-pattern/abstract-factory-pattern/</guid>
      <description></description>
    </item>
    
    <item>
      <title>工廠模式 | Factory Pattern</title>
      <link>https://ianjustin39.github.io/ianlife/design-pattern/factory-pattern/</link>
      <pubDate>Fri, 18 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/design-pattern/factory-pattern/</guid>
      <description></description>
    </item>
    
    <item>
      <title>單例模式 | Singleton Pattern</title>
      <link>https://ianjustin39.github.io/ianlife/design-pattern/singleton-pattern/</link>
      <pubDate>Thu, 17 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/design-pattern/singleton-pattern/</guid>
      <description></description>
    </item>
    
    <item>
      <title>迪米特法則 | Law of Demeter</title>
      <link>https://ianjustin39.github.io/ianlife/design-pattern/law-of-demeter/</link>
      <pubDate>Wed, 16 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/design-pattern/law-of-demeter/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    各單元對其他單元所知應當有限：只瞭解與目前單元最相關之單元</description>
    </item>
    
    <item>
      <title>合成/聚合複用原則 | Composite/Aggregate Reuse Principle</title>
      <link>https://ianjustin39.github.io/ianlife/design-pattern/composite-aggregate-reuse-principle/</link>
      <pubDate>Tue, 15 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/design-pattern/composite-aggregate-reuse-principle/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    盡量使用組合(contains-a)/聚合(has-a)方式來代替繼承(is-a)來達到重複使用的目的</description>
    </item>
    
    <item>
      <title>依賴反轉原則 | Dependency Inversion Principle</title>
      <link>https://ianjustin39.github.io/ianlife/design-pattern/dependence-inversion-principle/</link>
      <pubDate>Mon, 14 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/design-pattern/dependence-inversion-principle/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    依賴反轉原則(DIP)的定義有兩點：</description>
    </item>
    
    <item>
      <title>介面隔離原則 | Interface Segregation Principle</title>
      <link>https://ianjustin39.github.io/ianlife/design-pattern/interface-segregation-principle/</link>
      <pubDate>Sun, 13 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/design-pattern/interface-segregation-principle/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    Clients should not be forced to depend on methods that they do not use.</description>
    </item>
    
    <item>
      <title>里氏替換原則 | Liskov Substitution Principle</title>
      <link>https://ianjustin39.github.io/ianlife/design-pattern/liskov-substitution-principle/</link>
      <pubDate>Sat, 12 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/design-pattern/liskov-substitution-principle/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T, the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.</description>
    </item>
    
    <item>
      <title>開閉原則 | Open/Closed Principle</title>
      <link>https://ianjustin39.github.io/ianlife/design-pattern/open-closed-principle/</link>
      <pubDate>Fri, 11 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/design-pattern/open-closed-principle/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    Software entities like classes, modules and functions should be open for extension but closed for modifications.</description>
    </item>
    
    <item>
      <title>單一職責原則 | Single Responsibility Principle</title>
      <link>https://ianjustin39.github.io/ianlife/design-pattern/single-responsibility-principle/</link>
      <pubDate>Thu, 10 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/design-pattern/single-responsibility-principle/</guid>
      <description>本系列文章同步分享於IT邦幫忙第12屆鐵人賽
   Design Pattern 系列文章導讀     Design Pattern可以說是開發上大家都會遇到的一個課題， 這系列文會從Design Principles、各種design pattern到最後的Anti-Patterns &amp; Code Smells介紹下去，讓我們可以更了解各種pattern的使用時機與場合。 預計目標主題如下，若有哪部分不熟的章節可以直接點進去看 註：可以利用Online Java Compiler IDE      設計模式 - 入門篇  什麼是Design Pattern? Design Pattern的類型與原則    設計模式 - 原則篇 | Design Principles  單一職責原則 | Single Responsibility Principle 開閉原則 | Open/Closed Principle 里氏替換原則 | Liskov Substitution Principle 介面隔離原則 | Interface Segregation Principle 依賴反轉原則 | Dependency Inversion Principle 合成/聚合複用原則 | Composite/Aggregate Reuse Principle 迪米特法則 | Law of Demeter    設計模式 - 創建型模型篇 | Creational Patterns  單例模式 | Singleton Pattern 工廠模式 | Factory Pattern 抽象工廠模式 | Abstract Factory Pattern 生成器模式 | Builder Pattern 原型模式 | Prototype Pattern    設計模式 - 結構型模型篇 | Structural Patterns  適配器模式 | Adapter Pattern 橋接模式 | Bridge Pattern 组合模式 | Composite Pattern 裝飾者模式 | Decorator Pattern 外觀模式 | Facade Pattern 享元模式 | Flyweight Pattern 代理模式 | Proxy Pattern    設計模式 - 行為型模型篇 | Behavioural Patterns  責任鏈模式 | Chain of Responsibility Pattern 命令模式 | Command Pattern 迭代器模式 | Iterator Pattern 中介者模式 | Mediator Pattern 狀態模式 | State Pattern 備忘錄模式 | Memento Pattern 觀察者模式 | Observer Pattern Strategy Pattern Template Pattern Visitor Pattern Interpreter Pattern    設計模式 - 番外篇  Anti-Patterns Code Smells Design Pattern VS 演算法       定義    There should never be more than one reason for a class to change.</description>
    </item>
    
    <item>
      <title>Design Pattern的類型與原則</title>
      <link>https://ianjustin39.github.io/ianlife/design-pattern/design-patterns-and-principle/</link>
      <pubDate>Wed, 09 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/design-pattern/design-patterns-and-principle/</guid>
      <description>&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10235045&#34; target=&#34;_blank&#34;&gt;本系列文章同步分享於IT邦幫忙第12屆鐵人賽&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;</description>
    </item>
    
    <item>
      <title>什麼是Design Pattern?</title>
      <link>https://ianjustin39.github.io/ianlife/design-pattern/what_is_design_pattern/</link>
      <pubDate>Tue, 08 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/design-pattern/what_is_design_pattern/</guid>
      <description>&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;https://ithelp.ithome.com.tw/articles/10234830&#34; target=&#34;_blank&#34;&gt;本系列文章同步分享於IT邦幫忙第12屆鐵人賽&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;自從當上了工程師後，大多數時間都負責後端的程式開發，從最一開始設計api到現在sdk的經驗中，了解到一個好的程式架構及設計，不只可以讓後續維運成本降低，往後要擴充也會相對容易許多。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>用Bootstrap &#43; Masonry &#43; magnific Popup架設個人相簿</title>
      <link>https://ianjustin39.github.io/ianlife/build-blog/build_photograph_in_hugo/</link>
      <pubDate>Wed, 06 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/build-blog/build_photograph_in_hugo/</guid>
      <description>&lt;p&gt;剛開始架設網站時就決定要在網站內架一個相簿，這篇會分享如何用Bootstrap+Masonry+magnificPopup建構屬於你自己的相片牆&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>部署Hugo個人網頁至GitHub</title>
      <link>https://ianjustin39.github.io/ianlife/build-blog/deploy_hugo_on_github/</link>
      <pubDate>Sat, 02 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/build-blog/deploy_hugo_on_github/</guid>
      <description>&lt;p&gt;之前用Hugo架設個人網站，但架設完成後還是需要部署到一個平台，才有辦法瀏覽，
這篇就來分享如何將網頁部署到GitHub以及途中遇到的一些問題&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>使用Hugo建立個人網頁</title>
      <link>https://ianjustin39.github.io/ianlife/build-blog/get_started_hugo/</link>
      <pubDate>Thu, 30 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ianjustin39.github.io/ianlife/build-blog/get_started_hugo/</guid>
      <description>&lt;p&gt;一直有想要寫一些文章記錄生活，身為一個工程師，難免會有想要自己架設的靈魂（？，
最近發現hugo可以快速架站，除了有template以外也可以自己更改裡面的配置
，對於一個前端小菜鳥來說，算是一大福音ＸＤ，於是開始了這條漫漫長路～&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>